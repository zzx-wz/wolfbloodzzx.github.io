<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>知识有限分子</title>
  
  <subtitle>扯淡为主，瞎掰为辅</subtitle>
  <link href="http://blog.zevzhang.top/atom.xml" rel="self"/>
  
  <link href="http://blog.zevzhang.top/"/>
  <updated>2022-10-10T03:19:48.000Z</updated>
  <id>http://blog.zevzhang.top/</id>
  
  <author>
    <name>zzx</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>聊聊c++中的移动语义</title>
    <link href="http://blog.zevzhang.top/2022/10/10/%E8%81%8A%E8%81%8Ac%E4%B8%AD%E7%9A%84%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/"/>
    <id>http://blog.zevzhang.top/2022/10/10/%E8%81%8A%E8%81%8Ac%E4%B8%AD%E7%9A%84%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/</id>
    <published>2022-10-10T03:19:48.000Z</published>
    <updated>2022-10-10T03:19:48.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://pic.zevzhang.top/blog/images/2022/10/17/b46dcbc57c2e4cbdca32e35541b19689.jpg" title="Photo by Niranjan _ Photograph on Unsplash"></p><p>c++11中引入的移动语义和std::move函数，是一个非常容易让人疑惑的点。正好最近在开发中遇到了几个std::move使用不当造成的bug，网上关于移动语义的资料很多，正好借着这个机会，按照我的理解好好盘一盘c++11里的移动语义到底做了一件什么事儿。</p><span id="more"></span><h2 id="所谓的赋值语句，到底做了一件什么事儿"><a href="#所谓的赋值语句，到底做了一件什么事儿" class="headerlink" title="所谓的赋值语句，到底做了一件什么事儿"></a>所谓的赋值语句，到底做了一件什么事儿</h2><p>想聊明白移动语义，很多资料其实上来就在讲左右值和左右值引用，诚然这两个概念在C++11里通常是绑定在一起来理解的，不过我还是想换个思路，从赋值语句开始来聊聊这件事。为了更容易去理解，我们以下的讨论只针对用户自定义的class和struct，不考虑c++中的基础数据类型。</p><p>我们首先通过几个case来看一下类对象调用赋值语句会发生什么情况。</p><p><strong>case 1：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> value): <span class="built_in">value_</span>(value) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">value</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> value_;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Test <span class="title">a</span><span class="params">(<span class="number">1</span>)</span>, <span class="title">b</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    a = b;</span><br><span class="line">    std::cout &lt;&lt; t.<span class="built_in">value</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; a.<span class="built_in">value</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码地输出结果很显然，两行都是b的value值2，代码执行的逻辑是符合我们预期的，在执行a &#x3D; b的时候，程序将value的值b赋值给了a这个新对象，尽管a与b是两个完全独立的对象，赋值语句将b的值copy给了a。</p><p><strong>case 2：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> value): <span class="built_in">value_</span>(value) &#123; data_ = <span class="keyword">new</span> <span class="type">int</span>[value]; &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123;<span class="keyword">delete</span> data_;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">value</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> value_;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span>* <span class="title">data_ptr</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> data_;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value_;</span><br><span class="line">    <span class="type">int</span>* data_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Test <span class="title">a</span><span class="params">(<span class="number">1</span>)</span>, <span class="title">b</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    Test a = b;</span><br><span class="line">    std::cout &lt;&lt; (<span class="type">uint64_t</span>) a.<span class="built_in">data_ptr</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; (<span class="type">uint64_t</span>) t.<span class="built_in">data_ptr</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码逻辑也很简单，合理的预期是用户创建Test对象的同时，会申请一块长度为value的内存给这个对象持有。我们试着执行这段函数，首先从打印结果上来看，两行打印出来的对象持有的这块内存地址是相同的，另外不出预料的话，程序会报出一个double free的运行时错误，这显然不符合了我们的设计初衷，a和b共同持有了一块相同的内存，任何一个对象对data_的操作都会影响到另外一个对象中持有的data_。</p><p>c++文档在赋值运算符一章里对赋值运算符有这样的定义[^1]:</p><blockquote><p>copy assignment operator replaces the contents of the object a with a copy of the contents of b (b is not modified). For class types, this is a special member function, described in copy assignment operator.</p></blockquote><p>在case1和case2这种情况里，我们没有重载过赋值运算符，a &#x3D; b其实调用了默认的赋值运算符，a的content会直接repace成b的值。这个逻辑在case1中没有问题，但在case2中这种需要自己管理内存的场景下，指针的值（内存地址）也将作为一个content直接copy到b中，显然不能满足我们的需求。因此为了能让每个对象自己持有内存地址，我们需要重载opertor&#x3D;，来让c++做一些特定的操作。</p><p><strong>case 3：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Test</span><span class="params">(<span class="type">int</span> size)</span>: size_(size) &#123;</span> data_ = <span class="keyword">new</span> <span class="type">int</span>[size_]; &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123;<span class="keyword">delete</span> data_;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> size_;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span>* <span class="title">data_ptr</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> data_;&#125;</span><br><span class="line"></span><br><span class="line">    Test &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Test &amp;other) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;This is copy= operator&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">if</span> (&amp;other != <span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] data_;</span><br><span class="line">            size_ = other.size_;</span><br><span class="line">            data_ = <span class="keyword">new</span> <span class="type">int</span>[size_];</span><br><span class="line">            std::<span class="built_in">copy</span>(&amp;other.data_[<span class="number">0</span>], &amp;other.data_[<span class="number">0</span>] + size_, &amp;data_[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> size_;</span><br><span class="line">    <span class="type">int</span>* data_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们将Test类增加一个&#x3D;操作符号的重载函数，再次执行<strong>case 2</strong>的main函数，此时输出会变成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">This is copy= operator</span><br><span class="line">94493275451056</span><br><span class="line">94493275451088</span><br></pre></td></tr></table></figure><p>好了，我们看到内存地址已经不同了。</p><p>通过上面的三个case，我们可以总结出两个关于类对象进行赋值运算相关的特性：</p><ul><li>c++中针对赋值运算的实现是通过赋值运算符（operator&#x3D;）函数来实现的</li><li>c++中提供了默认的赋值运算符（浅拷贝），但是在某些情况下默认赋值运算符满足我们的需求，用户需要自行重载赋值运算符来实现更复杂的功能，例如case 2和case 3中的内存拷贝（深拷贝）</li></ul><h2 id="拷贝赋值与移动赋值"><a href="#拷贝赋值与移动赋值" class="headerlink" title="拷贝赋值与移动赋值"></a>拷贝赋值与移动赋值</h2><p>其实大部分场景下，通过<strong>case 3</strong>中类似的操作，即对Test&amp; operator&#x3D;(const Test&amp; other)进行重载，基本上能满足我们日常的开发需求。</p><p>但仔细观察很容易发现，每次调用一次赋值运算符，data_都需要重新申请一块新内存并进行一次内存拷贝，是否所有的场景里都需要申请新的内存呢？</p><p>我们看一下下面的例子：</p><p><strong>case 4</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Test</span><span class="params">(<span class="type">int</span> size)</span>: size_(size) &#123;</span> data_ = <span class="keyword">new</span> <span class="type">int</span>[size_]; &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~Test&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span> data_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> size_;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span>* <span class="title">data_ptr</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> data_;&#125;</span><br><span class="line"></span><br><span class="line">    Test &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Test &amp;other) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;This is copy= operator&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">if</span> (&amp;other != <span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] data_;</span><br><span class="line">            size_ = other.size_;</span><br><span class="line">            data_ = <span class="keyword">new</span> <span class="type">int</span>[size_];</span><br><span class="line">            std::<span class="built_in">copy</span>(&amp;other.data_[<span class="number">0</span>], &amp;other.data_[<span class="number">0</span>] + size_, &amp;data_[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> size_;</span><br><span class="line">    <span class="type">int</span>* data_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Test <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    a = <span class="built_in">Test</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述代码，我们先创建了一个对象a，然后对a通过a &#x3D; Test(10)进行了一次更新。程序输出如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">This is copy= <span class="keyword">operator</span></span><br><span class="line">~Test</span><br><span class="line">~Test</span><br></pre></td></tr></table></figure><p>我们观察输出的结果，这里显然进行了一次内存申请和内存拷贝。仔细思考这个过程，Test(10)首先创建了一个临时对象申请了一块内存，在这条赋值语句执行结束了之后，这个临时的对象生命周期就已经结束了，此时临时对象中的数据也销毁了。进一步思考，总之临时变量在这次运行结束后也会被销毁，我们若能直接把这个临时对象中的资源承接过来转移到a中，似乎就可以减少一次内存申请和拷贝，并且对整个程序来说也是安全的。</p><p>于是，关于赋值，貌似出现了两种选择：</p><ol><li>赋值之后原对象需要保留，此时需要将原对象中的值拷贝到新对象（<strong>拷贝语义 - 拷贝赋值</strong>）</li><li>赋值之后原对象可销毁，此时可以将原对象中的资源转移到新对象并等待原对象销毁（<strong>移动语义 - 移动赋值</strong>）</li></ol><p>显然，一个operator&#x3D;的重载已经没办法满足我们的需求，case 3给出了一个典型的拷贝赋值的实现，显然我们还需要一个移动赋值的实现。要实现这个功能，最重要的是要把上述的两种情况合理表达出来（这涉及到区分原对象是否有保留的价值）。这里c++为了更好地描述类似地情况，引入了<strong>左值和右值</strong>的概念，关于左值右值更详细的描述，可以参考[^2]和[^3]，强烈建议好好读一读。在这里，我们只需要清楚，<strong>在移动语义下，右值才可以在使用完成后直接销毁，承担资源转移的功能</strong>。</p><p>于是，我们可以声明一个Test &amp;operator&#x3D;(Test &amp;&amp;other)函数，来专门处理右值。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Test</span><span class="params">(<span class="type">int</span> size)</span> : size_(size) &#123;</span> data_ = <span class="keyword">new</span> <span class="type">int</span>[size_]; &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~Test&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span>[] data_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> size_; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> *<span class="title">data_ptr</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> data_; &#125;</span><br><span class="line"></span><br><span class="line">    Test &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Test &amp;other) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;This is copy= operator&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">if</span> (&amp;other != <span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] data_;</span><br><span class="line">            size_ = other.size_;</span><br><span class="line">            data_ = <span class="keyword">new</span> <span class="type">int</span>[size_];</span><br><span class="line">            std::<span class="built_in">copy</span>(&amp;other.data_[<span class="number">0</span>], &amp;other.data_[<span class="number">0</span>] + size_, &amp;data_[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Test &amp;<span class="keyword">operator</span>=(Test &amp;&amp;other) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;This is move= operator&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] data_;</span><br><span class="line">            data_ = other.data_;</span><br><span class="line">            size_ = other.size_;</span><br><span class="line">            other.data_ = <span class="literal">nullptr</span>;</span><br><span class="line">            other.size_ = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> size_;</span><br><span class="line">    <span class="type">int</span> *data_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Test <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    a = <span class="built_in">Test</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">This is move= <span class="keyword">operator</span></span><br><span class="line">~Test</span><br><span class="line">~Test</span><br></pre></td></tr></table></figure><p>运行上述代码，我们可以观察到程序执行了移动赋值，资源在两个对象间进行了转移。</p><h2 id="拷贝构造与移动构造"><a href="#拷贝构造与移动构造" class="headerlink" title="拷贝构造与移动构造"></a>拷贝构造与移动构造</h2><p>同理，移动语义与拷贝语义的概念，我们也可以拓展到构造函数上，引入拷贝构造与移动构造的概念。例如对于如下代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Test <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">Test b = a;</span><br><span class="line">Test c = std::<span class="built_in">move</span>(a);</span><br></pre></td></tr></table></figure><p>Test b &#x3D; a的实现需要依赖Test(Test&amp; test)构造函数实现，类似移动赋值，Test c &#x3D; std::move(a)也需要来专门识别右值的构造函数Test(Test&amp;&amp; test)来实现，完整代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Test</span><span class="params">(<span class="type">int</span> size)</span> : size_(size) &#123;</span> data_ = <span class="keyword">new</span> <span class="type">int</span>[size_]; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Test</span>(Test&amp; test): <span class="built_in">size_</span>(<span class="number">0</span>), <span class="built_in">data_</span>(<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;copy construct&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        *<span class="keyword">this</span> = test;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Test</span>(Test&amp;&amp; test): <span class="built_in">size_</span>(<span class="number">0</span>), <span class="built_in">data_</span>(<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;move construct&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        *<span class="keyword">this</span> = test;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Test</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~Test&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span>[] data_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> size_; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> *<span class="title">data_ptr</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> data_; &#125;</span><br><span class="line"></span><br><span class="line">    Test &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Test &amp;other) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;This is copy= operator&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">if</span> (&amp;other != <span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] data_;</span><br><span class="line">            size_ = other.size_;</span><br><span class="line">            data_ = <span class="keyword">new</span> <span class="type">int</span>[size_];</span><br><span class="line">            std::<span class="built_in">copy</span>(&amp;other.data_[<span class="number">0</span>], &amp;other.data_[<span class="number">0</span>] + size_, &amp;data_[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Test &amp;<span class="keyword">operator</span>=(Test &amp;&amp;other) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;This is move= operator&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] data_;</span><br><span class="line">            data_ = other.data_;</span><br><span class="line">            size_ = other.size_;</span><br><span class="line">            other.data_ = <span class="literal">nullptr</span>;</span><br><span class="line">            other.size_ = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> size_;</span><br><span class="line">    <span class="type">int</span> *data_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Test <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    Test b = a;</span><br><span class="line">    Test c = std::<span class="built_in">move</span>(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有兴趣可以自行执行一下上述代码，在这里就不深入讨论了。关于移动构造和拷贝构造更详细的资料可以查看[^4]、[^5]、[^6]和[^7]。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好了，到这里我们可以简单总结一下了：</p><ul><li>移动语义的主要目的就是为了<strong>性能优化</strong>，是为了将一个<strong>即将释放的目标对象</strong>中的资源移动到新对象里，以便<strong>以最小的代价构建新对象</strong>。</li><li>移动语义的相关操作中，被移动的对象在移动后资源已经被移动走，该对象应该被释放或生命周期结束自动释放，<strong>不应有任何后续的操作</strong>。</li><li>c++中的自定义的类原生不支持移动语义，而是通过重载&#x3D;运算符和构造函数来实现的，其核心的原理是在移动语义中，<strong>被移动的对象必须是右值</strong>，因此可以通过重载参数为右值引用的&#x3D;运算符和构造函数，代码在编译过程中就可以根据类型推断来判断释放用户要进行移动操作，具体如何移动是根据用户的实现来进行的。</li><li>对于一个类来说，移动语义相关的函数并不是必须的，<strong>在设计类时若没有显式重载移动语义相关的函数，默认是会直接按照拷贝语义相关的操作来进行的</strong>。</li></ul><h2 id="回过头说一嘴std-move"><a href="#回过头说一嘴std-move" class="headerlink" title="回过头说一嘴std::move"></a>回过头说一嘴std::move</h2><p>到此，我们回过头来再看一下std::move这个操作。在很多移动语义相关的逻辑里我们都能看到std::move的身影。很多文档中都说std::move实际上没有移动任何东西，只是将左值转换为右值。基于上述的一系列讨论，我们似乎更容易理解std::move存在的意义。在代码里，我们可能有很多需要将左值进行移动的操作，移动语义又是通过右值引用作为参数来推断使用哪个构造或者赋值函数的。在这种情况下，std::move将左值类型转换成了右值，进而触发了移动语义相关的构造或者赋值函数。</p><p>因此，std::move相当于只进行了类型转换，真正移动相关的操作还是通过类内部的移动赋值和移动构造函数来实现的。再进一步，假如某一个类自己本身没重载移动赋值和移动构造函数，尽管在一些场景下调用了std::move，相关操作还是会被默认的拷贝函数承接，不会触发任何移动相关的操作。</p><p>[^1]: <a href="https://en.cppreference.com/w/cpp/language/operator_assignment">Assignment operators - cppreference.com</a></p><p>[^2]: <a href="https://en.cppreference.com/w/cpp/language/value_category">Value categories - cppreference.com</a></p><p>[^3]: <a href="https://learn.microsoft.com/zh-cn/cpp/cpp/lvalues-and-rvalues-visual-cpp?view=msvc-170">Lvalues 和 Rvalues (C++)</a></p><p>[^4]: <a href="https://en.cppreference.com/w/cpp/language/move_constructor">Move constructors - cppreference.com</a></p><p>[^5]: <a href="https://en.cppreference.com/w/cpp/language/copy_constructor">Copy constructors - cppreference.com</a></p><p>[^6]: <a href="https://learn.microsoft.com/zh-cn/cpp/cpp/copy-constructors-and-copy-assignment-operators-cpp?view=msvc-170">复制构造函数和复制赋值运算符 (C++)</a></p><p>[^7]: <a href="https://learn.microsoft.com/zh-cn/cpp/cpp/move-constructors-and-move-assignment-operators-cpp?view=msvc-170">移动构造函数和移动赋值运算符 (C++)</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;http://pic.zevzhang.top/blog/images/2022/10/17/b46dcbc57c2e4cbdca32e35541b19689.jpg&quot; title=&quot;Photo by Niranjan _ Photograph on Unsplash&quot;&gt;&lt;/p&gt;
&lt;p&gt;c++11中引入的移动语义和std::move函数，是一个非常容易让人疑惑的点。正好最近在开发中遇到了几个std::move使用不当造成的bug，网上关于移动语义的资料很多，正好借着这个机会，按照我的理解好好盘一盘c++11里的移动语义到底做了一件什么事儿。&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="http://blog.zevzhang.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="c++" scheme="http://blog.zevzhang.top/tags/c/"/>
    
    <category term="编程" scheme="http://blog.zevzhang.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>2021年那些印象深刻的播客节目</title>
    <link href="http://blog.zevzhang.top/2022/02/20/2021%E5%B9%B4%E9%82%A3%E4%BA%9B%E8%AE%A9%E6%88%91%E5%8D%B0%E8%B1%A1%E6%B7%B1%E5%88%BB%E7%9A%84%E6%92%AD%E5%AE%A2%E8%8A%82%E7%9B%AE%E7%9B%98%E7%82%B9/"/>
    <id>http://blog.zevzhang.top/2022/02/20/2021%E5%B9%B4%E9%82%A3%E4%BA%9B%E8%AE%A9%E6%88%91%E5%8D%B0%E8%B1%A1%E6%B7%B1%E5%88%BB%E7%9A%84%E6%92%AD%E5%AE%A2%E8%8A%82%E7%9B%AE%E7%9B%98%E7%82%B9/</id>
    <published>2022-02-20T08:34:08.000Z</published>
    <updated>2021-02-22T14:58:08.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://pic.zevzhang.top/blog/images/2022/01/05/d9db02749544c3a9819a4f12542a6777.jpeg" title="Photo by Amr Taha™ on Unsplash"></p><p>如果说2020年是中文播客爆发的前夜，那2021年一定能算得上是中文播客的元年。</p><p>我虽然算不上是播客的原住民，但也见证了苹果的podcast首页热门节目榜，从相声、段子、英语、郭德纲于谦十年精选，到今天的大内密谈、忽左忽右、日谈公园等一众中文播客的百家争鸣，也见证了小宇宙从内测到上线再到产品功能的不断完善。播客已经成为了我每天上班下班漫长通勤路上的重要组成部分。</p><p>最近总算闲一点了，翻开小宇宙看了一下，过去的一年里听了不少有意思的节目。我关注的频道大体应该可以分为四大类：科技、商业、娱乐、人文社科，去年一年林林总总也收藏了一些有意思的节目，趁着21年还没走远，好好整理了一下2021年那些让我印象深刻的播客节目，这几期节目有的轻松，有的严肃，但都给我带来了很多有价值的启发与思考，其中有些甚至刷了好多遍，在这里简单整理了一下与大家分享。</p><span id="more"></span><h2 id="【凑近点看】VOL-10-我不想重启2020×熊浩：我们该如何反抗脆弱？"><a href="#【凑近点看】VOL-10-我不想重启2020×熊浩：我们该如何反抗脆弱？" class="headerlink" title="【凑近点看】VOL 10 - 我不想重启2020×熊浩：我们该如何反抗脆弱？"></a>【凑近点看】<a href="https://www.xiaoyuzhoufm.com/episode/5feaeef2dee9c1e16df53c15?s=eyJ1IjogIjVmODFlMjhjZTBmNWU3MjNiYjk2MTc3YSJ9">VOL 10 - 我不想重启2020×熊浩：我们该如何反抗脆弱？</a></h2><p><img src="http://pic.zevzhang.top/blog/images/2022/01/13/4fccb60a35066bd9751f3569ae696b4f.png"></p><p>这期节目是2020年12月29日的节目，原本应该算是20年的节目，但我听到这期节目的时候已经是2021年1月，姑且也算到2021年的节目盘点里吧～～</p><p>这期是真的宝藏，几个主播一边插科打诨，氛围非常轻松，同时又强烈输出，话题深度与信息密度极高，每次听都会收获一些新的感悟。尤其是熊浩老师的关于学习，关于跟自己相处，关于人生规划的思考，给了我非常大的触动。</p><p>顺带说一句，几个主播也太会聊天了，观点输出非常流畅，语言表达非常舒服。像“如果能重来，奋不顾身也不并不珍贵，孤注一掷也不并不壮烈”、“我开始懂得了古人为什么要闭关，就是要用慢的流速让自己能够不断地降落和堆叠”，整期节目随便摘出来一段对话都是这样的金句。</p><p>年度最佳！！强烈推荐！！</p><h2 id="【声东击西】-196-请收下这枚记录-2021-年的声音时光胶囊"><a href="#【声东击西】-196-请收下这枚记录-2021-年的声音时光胶囊" class="headerlink" title="【声东击西】#196 请收下这枚记录 2021 年的声音时光胶囊"></a>【声东击西】<a href="https://www.xiaoyuzhoufm.com/episode/61cba58a77c2fd938c5ece0a?s=eyJ1IjogIjVmODFlMjhjZTBmNWU3MjNiYjk2MTc3YSJ9">#196 请收下这枚记录 2021 年的声音时光胶囊</a></h2><p><img src="http://pic.zevzhang.top/blog/images/2022/01/13/84af1fe5fb226ee5e7e4727d53b7c922.png"> </p><p>我应该能算得上声东击西的老粉丝了，时光胶囊系列是我非常喜欢的一个系列，用声音去回顾一整年是一个不错的体验。说实话，从我个人角度我认为21年的声音胶囊略逊色于20年的，21年的盘点多了很多时政大事，少了些小人物在大时代背景下的声音，尽管如此却不妨碍这是一期好节目。</p><p>21年已经是与疫情共处的第二个年头了，来回反复的疫情似乎加快了时间前进的节奏，模糊了我们对时间的感知。一边听着这期节目中的声音，一边感慨声音背后的事件仿佛都还发生在昨天一样，等节目听完才恍惚发现，原来2021年，我们经历并见证了这么多大事。</p><p>非常赞的节目，推荐大家闲暇的时候听一听，用声音带着自己回顾整个2021。</p><h2 id="【贝望录】48-谁说葡萄酒不能兑汽水"><a href="#【贝望录】48-谁说葡萄酒不能兑汽水" class="headerlink" title="【贝望录】48. 谁说葡萄酒不能兑汽水"></a>【贝望录】<a href="https://www.xiaoyuzhoufm.com/episode/609b1a8e6b7c6f99ebc4c35e?s=eyJ1IjogIjVmODFlMjhjZTBmNWU3MjNiYjk2MTc3YSJ9">48. 谁说葡萄酒不能兑汽水</a></h2><p><img src="http://pic.zevzhang.top/blog/images/2022/01/13/42ab3f333c208d0adf7ed3e914df7575.jpeg"></p><p>贝望录是我每期必追的播客频道，非常喜欢Bessie老师轻松幽默的风格，同时也拓宽了自己很多的商业知识。聊葡萄酒这期是我个人非常非常喜欢的一期，作为一个定期馋酒的小酒鬼，听着嘉宾凤仪老师操着一嘴蹩脚中文，但又如此接地气地跟大家聊葡萄酒，简直是无比轻松享受的过程。</p><p>喝酒本就应该是一件轻松的事儿，抛开那些乱七八糟的规矩吧，就像凤仪老师说的，“如果你没有那么多（葡萄酒的）知识，你反而会更开放地喝酒“。所以，谁说葡萄酒不能兑汽水？</p><h2 id="【子非鱼】子非鱼E64-三人聊《三体》：影视剧，历史书，博弈论？"><a href="#【子非鱼】子非鱼E64-三人聊《三体》：影视剧，历史书，博弈论？" class="headerlink" title="【子非鱼】子非鱼E64 | 三人聊《三体》：影视剧，历史书，博弈论？"></a>【子非鱼】<a href="https://www.xiaoyuzhoufm.com/episode/618e5e69ec933f52be85807c?s=eyJ1IjogIjVmODFlMjhjZTBmNWU3MjNiYjk2MTc3YSJ9">子非鱼E64 | 三人聊《三体》：影视剧，历史书，博弈论？</a></h2><p><img src="http://pic.zevzhang.top/blog/images/2022/01/13/c4674a9517fb509821ec7761c5959c14.png"></p><p>这期子非鱼聊的《三体》，是我近年来听过的关于三体这本书聊的非常深入的一期的节目。</p><p>第一次接触《三体》还是在高中时蹭同桌的《科幻世界》，后来大一时间空闲了，陆陆续续把《三体》三部全部读完后，彻底被大刘圈粉。这期的子非鱼，三个主播从很多新的角度聊了聊读《三体》的感触，就像Gareth开篇破题时说的：“……各自的经历或者职业比较大……大家应该各自能从三体里收获到自己比较想要的，或者特别有感触的东西”</p><p>“一千个读者心中有一千个哈姆雷特”，一千个读三体的读者中，应该也有一千份读《三体》的收获吧。</p><p>PS: 祝乾亮老师的三体系列真的太赞了！</p><h2 id="【贝望录】61-把茶叶卖给年轻人有多难？"><a href="#【贝望录】61-把茶叶卖给年轻人有多难？" class="headerlink" title="【贝望录】61. 把茶叶卖给年轻人有多难？"></a>【贝望录】<a href="https://www.xiaoyuzhoufm.com/episode/611c4da29edcaf59e47aaf21?s=eyJ1IjogIjVmODFlMjhjZTBmNWU3MjNiYjk2MTc3YSJ9">61. 把茶叶卖给年轻人有多难？</a></h2><p><img src="http://pic.zevzhang.top/blog/images/2022/01/13/42ab3f333c208d0adf7ed3e914df7575.jpeg"></p><p>贝望录又上榜了～～</p><p>我曾经跟朋友们开玩笑说，如果我要去创业的话，我一定会去卖那些成瘾性高的产品，比如咖啡、酒饮料或者茶。然而冷静想一想，无论是咖啡还是酒饮料，最近两年相关赛道都越来越火热，但反观茶饮类，除了勉强能被算到含茶饮料的果茶、奶茶这两年杀疯了以外，传统的茶类赛道看上去还是保持着老样子，很难有新的突破，年轻人也似乎离茶叶越来越远。</p><p>这期贝望录从茶行业的发展、茶叶在年轻人中的普及等方面，输出了很多值得思考的观点。其中有一点，关于年轻人与历史的话题上，嘉宾的观点让我感触非常大，茶叶的本质首先是消费品，“如果我们把茶叶当成一种历史的载体来看，我们当然希望文化被继承，但是我们不希望它被这么沉重地被继承”。非常赞同嘉宾的观点，我们身边与传统文化相关的食物似乎都被背负了太多历史载体的使命，反而越来越难被年轻人接受。如同嘉宾所说的“如果让一款产品能普及到千家万户，你应该用最简单的方法去做，而不是用最复杂的方法去做”，放下历史的包袱，先把这些传承当作一个产品，从产品角度来思考怎么服务好当前用户的需求，可能是一种更好的继承方式吧。</p><h2 id="【乱翻书】-Vol-26-Web2-0-VS-Web3-0，对方辩友请发言（上）-Vol-27-Web2-0-VS-Web3-0，对方辩友请发言（下）"><a href="#【乱翻书】-Vol-26-Web2-0-VS-Web3-0，对方辩友请发言（上）-Vol-27-Web2-0-VS-Web3-0，对方辩友请发言（下）" class="headerlink" title="【乱翻书】 Vol.26 Web2.0 VS Web3.0，对方辩友请发言（上）  || Vol.27 Web2.0 VS Web3.0，对方辩友请发言（下）"></a>【乱翻书】 <a href="https://www.xiaoyuzhoufm.com/episode/61bb8cf5898eaed596507419?s=eyJ1IjogIjVmODFlMjhjZTBmNWU3MjNiYjk2MTc3YSJ9">Vol.26 Web2.0 VS Web3.0，对方辩友请发言（上）</a>  || <a href="https://www.xiaoyuzhoufm.com/episode/61bb8e6a1773c5744af3f18a?s=eyJ1IjogIjVmODFlMjhjZTBmNWU3MjNiYjk2MTc3YSJ9">Vol.27 Web2.0 VS Web3.0，对方辩友请发言（下）</a></h2><p><img src="http://pic.zevzhang.top/blog/images/2022/01/13/0aaa064784d8650fa6f02ed8bde864d5.png"></p><p>潘乱老师的乱翻书是我非常喜欢的播客频道。乱翻书的大部分节目都是直播的声音版，很多嘉宾都是直接连麦过来的，录音质量说实话是真心差，声音比较糊，但盖不住内容赞，讨论的观点深刻又犀利，干货量非常高，强烈建议潘乱老师好好升级一下录音设备，多录一些线下节目。</p><p>这两期节目是一段讨论的上下半场，潘乱老师找来了一帮大佬，基本上分成了两个阵营来聊Web3.0。内容上说实话聊的有些松散，有一大段时间似乎嘉宾们有点自己聊自己的、频繁抛概念的感觉，同时内容专业度可能比较高，对于听众来说，能跟上嘉宾的节奏也需要提前储备一大波Web3.0的知识。尽管如此，我依旧选了这期节目，难得听到了一期如此深入聊Web3.0的节目。去年随着元宇宙、Web3.0这一波概念火了之后，我陆续听了好多标榜科技类播客的频道，云里雾里地跟风聊了一波Web3.0，内容也毫无新意，基本上都是在鼓吹Web3.0、元宇宙的美好愿景。这期节目我很欣喜地听到了不同的声音，听到了大佬们是对这些概念的解读，也听到了一些非常深入的思考与感悟。</p><p>另外，金叶宸老师后来还在三五环录了一期Web3.0的内容，由于不是辩论而是对谈的形式，观点表达地更清晰一点，顺手也放上链接：<a href="https://www.xiaoyuzhoufm.com/episode/61d5aa50ee197a3aac3dac8a?s=eyJ1IjogIjVmODFlMjhjZTBmNWU3MjNiYjk2MTc3YSJ9">No.58 跟金叶宸聊聊 Web3 和元宇宙</a></p><p>哦对了， 这一期的乱翻书，音质依旧感人……</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一波整理下来，发现2021年真的听了很多高质量的节目了，同时也很开心看到越来越多人开始录制自己的播客，尤其是小宇宙上线了首页推荐了之后，陆续听到了好多有意思的节目。在整理的过程中，我也回听了好多期被我点赞了之后就忘到箱底的节目，确实有一些优秀的内容值得好好记录整理一下。</p><p>2022年，我琢磨着搞个啥形式，定期把自己听过的节目，整理记录一下，可能是听后的感悟，或者是内容要点整理，总之借此写点东西，目前先放到这里吧。也希望2022年，能有更多的新的收获与体验。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;http://pic.zevzhang.top/blog/images/2022/01/05/d9db02749544c3a9819a4f12542a6777.jpeg&quot; title=&quot;Photo by Amr Taha™ on Unsplash&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果说2020年是中文播客爆发的前夜，那2021年一定能算得上是中文播客的元年。&lt;/p&gt;
&lt;p&gt;我虽然算不上是播客的原住民，但也见证了苹果的podcast首页热门节目榜，从相声、段子、英语、郭德纲于谦十年精选，到今天的大内密谈、忽左忽右、日谈公园等一众中文播客的百家争鸣，也见证了小宇宙从内测到上线再到产品功能的不断完善。播客已经成为了我每天上班下班漫长通勤路上的重要组成部分。&lt;/p&gt;
&lt;p&gt;最近总算闲一点了，翻开小宇宙看了一下，过去的一年里听了不少有意思的节目。我关注的频道大体应该可以分为四大类：科技、商业、娱乐、人文社科，去年一年林林总总也收藏了一些有意思的节目，趁着21年还没走远，好好整理了一下2021年那些让我印象深刻的播客节目，这几期节目有的轻松，有的严肃，但都给我带来了很多有价值的启发与思考，其中有些甚至刷了好多遍，在这里简单整理了一下与大家分享。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="http://blog.zevzhang.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="盘点" scheme="http://blog.zevzhang.top/tags/%E7%9B%98%E7%82%B9/"/>
    
    <category term="播客" scheme="http://blog.zevzhang.top/tags/%E6%92%AD%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>在后厂的二三事儿</title>
    <link href="http://blog.zevzhang.top/2021/12/31/%E5%9C%A8%E5%90%8E%E5%8E%82%E7%9A%84%E4%BA%8C%E4%B8%89%E4%BA%8B%E5%84%BF/"/>
    <id>http://blog.zevzhang.top/2021/12/31/%E5%9C%A8%E5%90%8E%E5%8E%82%E7%9A%84%E4%BA%8C%E4%B8%89%E4%BA%8B%E5%84%BF/</id>
    <published>2021-12-31T09:12:01.000Z</published>
    <updated>2021-12-31T09:12:01.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://pic.zevzhang.top/blog_img/20210819183709.jpeg" title="宇宙中心后厂村"></p><p>北京时间2021年12月31日，在朋友圈开始疯转2021年年终总结的时候，我突然觉得是不是自己也该动手写点什么呢？于是，在参加完公司的新年活动之后，在一片浓浓的划水气氛中，我在hexo上拉了一个新的post，准备写点东西。</p><span id="more"></span><p>要对2021年总结啦，写点啥的呢？今年经历的大事吗？搬家？度蜜月？准爸爸？工作顺利？工作不顺利？似乎有很多要记录要总结的，似乎又都不值得写下来。</p><p>我其实骨子里是一个挺爱吹牛逼的性格，我甚至觉得跟一群人喝酒侃大山是一件非常惬意的事。但是，当我准备跟风写个年终总结的时候，我发现，我确实不擅长写东西。</p><p>说一个最近的事儿吧，前几天跟朋友吃饭，大家聊起特斯拉股价，朋友说特斯拉的市值已经比头部的十大传统车企市值总和还要高了。作为当时在场唯一一个曾经高位持有特斯拉股票，并稳稳地在低位抛掉，然后看着它飙升到1000多的韭菜，我深信我对这个话题有一定的发言权。于是，我开始滔滔不绝地侃起我对特斯拉估值的理解，我列举了很多马斯克的个人魅力，例如煽动力有多强，执行力有多强，想法有多超前云云，也摆了很多特斯拉在造车方面的优势，比如智能化做的多么好，电池技术有多么牛逼，驾驶体验有多么赞，外形设计有多么科技等等。</p><p>等我侃完，朋友问了我一个问题，所以你说了这么多，到底为什么它的市值能到这么高？</p><p>对啊，我似乎只是说了一些主观上的感受，但仅仅只是因为这些就能让特斯拉估值到传统车企的十倍吗？我貌似并没有深入思考清楚这个问题，更严重的是，在回答这个问题的时候，我根本没有抓住问题的核心。我的逻辑链似乎是：因为马斯克牛，所以特斯拉造的车牛，所以特斯拉公司的市值就应该有这么高。但是，这个逻辑本身就是有问题的。后来，我花了一中午的时间，调研了各个研究机构对特斯拉的未来估值分析报告，也大体扫了一下特斯拉的财报，我发现我对特斯拉有了一个新的认识，它的高估值并不是仅仅是因为车造的好，还来自于它近乎夸张的成本控制，在自动驾驶、Robotaxi超前的布局，软件生态的未来的营收预期，还有大众对电动车市场巨大增长空间的看好。</p><p>这件事儿后，我自我反思了一下，我其实性格里是一个比较疏懒的人，“好求知而不求甚解”（此处并不是褒义词）似乎已经成了常态，对很多事物的理解上可能太理所当然地以为事情就是想当然的样子，在没思考清楚事情的本质之前，就急着去表达。思维是存在惰性的，在当下这个浮躁的环境里，深入思考貌似比表达更有价值；当然，高质量的表达也是需要训练的，逻辑清晰的表达是建立在深入思考的基础上，表达也是让思考释放价值有效途径。</p><p>于是，在2021年的最后一周，我整理了这个无人问津的博客。一方面想给表达找个出口，另一方面也希望督促自己深入思考，好好说话。未来这个博客，可能陆续更新一些文章，但估计频率不会太高，在这块属于自己的角落里，写一些生活的琐事感悟，记录一些自己的学习笔记，还有自己的一些反思总结，也希望给自己找一个交流分享的渠道。关于起名字上，我想了很多个老气横秋的名字，比如“静思录”，“思过录”，“思己斋”，想来想起还是算了吧，一方面以我的文化水平和表达能力，写下的狗屁文章会与名字之间产生巨大的违和感，另一方面本来就是记录生活和思考的笔记，犯不上非得拔高到多高的高度。鉴于目前且未来一段时间，可能都会在后厂附近绕来绕去，索性直接就叫“后厂村的二三事儿”吧。</p><p>好吧，扯了这么多，我貌似是要写个年终总结来着吧？多少还是写几句吧，2021年，对我来说可能经历了非常长的一段时间的浮躁期，同时也经历了很多让自己成长的事儿，真真切切让自己成长的事儿。想起13年去台湾社会实践，在打狗领事馆的参观的时候，那边有个投币抽签算卦的机器，我至今仍清楚的记得我抽到的卦辞：“意中若问神仙路，劝尔且退望高楼。宽心且守宽心坐，必然遇得贵人扶”。2021年底，再回忆起来感触良多。</p><p>最后的最后，2022年，希望自己诸事顺遂～～</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;http://pic.zevzhang.top/blog_img/20210819183709.jpeg&quot; title=&quot;宇宙中心后厂村&quot;&gt;&lt;/p&gt;
&lt;p&gt;北京时间2021年12月31日，在朋友圈开始疯转2021年年终总结的时候，我突然觉得是不是自己也该动手写点什么呢？于是，在参加完公司的新年活动之后，在一片浓浓的划水气氛中，我在hexo上拉了一个新的post，准备写点东西。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="http://blog.zevzhang.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="扯扯淡" scheme="http://blog.zevzhang.top/tags/%E6%89%AF%E6%89%AF%E6%B7%A1/"/>
    
  </entry>
  
</feed>

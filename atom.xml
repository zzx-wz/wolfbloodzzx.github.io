<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>知识有限分子</title>
  
  <subtitle>扯淡为主，瞎掰为辅</subtitle>
  <link href="http://blog.zevzhang.top/atom.xml" rel="self"/>
  
  <link href="http://blog.zevzhang.top/"/>
  <updated>2022-10-10T03:19:48.000Z</updated>
  <id>http://blog.zevzhang.top/</id>
  
  <author>
    <name>zzx</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>聊聊c++中的移动语义</title>
    <link href="http://blog.zevzhang.top/2022/10/10/%E8%81%8A%E8%81%8Ac%E4%B8%AD%E7%9A%84%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/"/>
    <id>http://blog.zevzhang.top/2022/10/10/%E8%81%8A%E8%81%8Ac%E4%B8%AD%E7%9A%84%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/</id>
    <published>2022-10-10T03:19:48.000Z</published>
    <updated>2022-10-10T03:19:48.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://pic.zevzhang.top/blog/images/2022/10/17/b46dcbc57c2e4cbdca32e35541b19689.jpg" title="Photo by Niranjan _ Photograph on Unsplash"></p><p>c++11中引入的移动语义和std::move函数，是一个非常容易让人疑惑的点。正好最近在开发中遇到了几个std::move使用不当造成的bug，网上关于移动语义的资料很多，正好借着这个机会，按照我的理解好好盘一盘c++11里的移动语义到底做了一件什么事儿。</p><span id="more"></span><h2 id="所谓的赋值语句，到底做了一件什么事儿"><a href="#所谓的赋值语句，到底做了一件什么事儿" class="headerlink" title="所谓的赋值语句，到底做了一件什么事儿"></a>所谓的赋值语句，到底做了一件什么事儿</h2><p>想聊明白移动语义，很多资料其实上来就在讲左右值和左右值引用，诚然这两个概念在C++11里通常是绑定在一起来理解的，不过我还是想换个思路，从赋值语句开始来聊聊这件事。为了更容易去理解，我们以下的讨论只针对用户自定义的class和struct，不考虑c++中的基础数据类型。</p><p>我们首先通过几个case来看一下类对象调用赋值语句会发生什么情况。</p><p><strong>case 1：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> value): <span class="built_in">value_</span>(value) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">value</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> value_;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Test <span class="title">a</span><span class="params">(<span class="number">1</span>)</span>, <span class="title">b</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    a = b;</span><br><span class="line">    std::cout &lt;&lt; t.<span class="built_in">value</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; a.<span class="built_in">value</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码地输出结果很显然，两行都是b的value值2，代码执行的逻辑是符合我们预期的，在执行a &#x3D; b的时候，程序将value的值b赋值给了a这个新对象，尽管a与b是两个完全独立的对象，赋值语句将b的值copy给了a。</p><p><strong>case 2：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> value): <span class="built_in">value_</span>(value) &#123; data_ = <span class="keyword">new</span> <span class="type">int</span>[value]; &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123;<span class="keyword">delete</span> data_;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">value</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> value_;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span>* <span class="title">data_ptr</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> data_;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value_;</span><br><span class="line">    <span class="type">int</span>* data_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Test <span class="title">a</span><span class="params">(<span class="number">1</span>)</span>, <span class="title">b</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    Test a = b;</span><br><span class="line">    std::cout &lt;&lt; (<span class="type">uint64_t</span>) a.<span class="built_in">data_ptr</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; (<span class="type">uint64_t</span>) t.<span class="built_in">data_ptr</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码逻辑也很简单，合理的预期是用户创建Test对象的同时，会申请一块长度为value的内存给这个对象持有。我们试着执行这段函数，首先从打印结果上来看，两行打印出来的对象持有的这块内存地址是相同的，另外不出预料的话，程序会报出一个double free的运行时错误，这显然不符合了我们的设计初衷，a和b共同持有了一块相同的内存，任何一个对象对data_的操作都会影响到另外一个对象中持有的data_。</p><p>c++文档在赋值运算符一章里对赋值运算符有这样的定义[^1]:</p><blockquote><p>copy assignment operator replaces the contents of the object a with a copy of the contents of b (b is not modified). For class types, this is a special member function, described in copy assignment operator.</p></blockquote><p>在case1和case2这种情况里，我们没有重载过赋值运算符，a &#x3D; b其实调用了默认的赋值运算符，a的content会直接repace成b的值。这个逻辑在case1中没有问题，但在case2中这种需要自己管理内存的场景下，指针的值（内存地址）也将作为一个content直接copy到b中，显然不能满足我们的需求。因此为了能让每个对象自己持有内存地址，我们需要重载opertor&#x3D;，来让c++做一些特定的操作。</p><p><strong>case 3：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Test</span><span class="params">(<span class="type">int</span> size)</span>: size_(size) &#123;</span> data_ = <span class="keyword">new</span> <span class="type">int</span>[size_]; &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123;<span class="keyword">delete</span> data_;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> size_;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span>* <span class="title">data_ptr</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> data_;&#125;</span><br><span class="line"></span><br><span class="line">    Test &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Test &amp;other) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;This is copy= operator&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">if</span> (&amp;other != <span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] data_;</span><br><span class="line">            size_ = other.size_;</span><br><span class="line">            data_ = <span class="keyword">new</span> <span class="type">int</span>[size_];</span><br><span class="line">            std::<span class="built_in">copy</span>(&amp;other.data_[<span class="number">0</span>], &amp;other.data_[<span class="number">0</span>] + size_, &amp;data_[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> size_;</span><br><span class="line">    <span class="type">int</span>* data_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们将Test类增加一个&#x3D;操作符号的重载函数，再次执行<strong>case 2</strong>的main函数，此时输出会变成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">This is copy= operator</span><br><span class="line">94493275451056</span><br><span class="line">94493275451088</span><br></pre></td></tr></table></figure><p>好了，我们看到内存地址已经不同了。</p><p>通过上面的三个case，我们可以总结出两个关于类对象进行赋值运算相关的特性：</p><ul><li>c++中针对赋值运算的实现是通过赋值运算符（operator&#x3D;）函数来实现的</li><li>c++中提供了默认的赋值运算符（浅拷贝），但是在某些情况下默认赋值运算符满足我们的需求，用户需要自行重载赋值运算符来实现更复杂的功能，例如case 2和case 3中的内存拷贝（深拷贝）</li></ul><h2 id="拷贝赋值与移动赋值"><a href="#拷贝赋值与移动赋值" class="headerlink" title="拷贝赋值与移动赋值"></a>拷贝赋值与移动赋值</h2><p>其实大部分场景下，通过<strong>case 3</strong>中类似的操作，即对Test&amp; operator&#x3D;(const Test&amp; other)进行重载，基本上能满足我们日常的开发需求。</p><p>但仔细观察很容易发现，每次调用一次赋值运算符，data_都需要重新申请一块新内存并进行一次内存拷贝，是否所有的场景里都需要申请新的内存呢？</p><p>我们看一下下面的例子：</p><p><strong>case 4</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Test</span><span class="params">(<span class="type">int</span> size)</span>: size_(size) &#123;</span> data_ = <span class="keyword">new</span> <span class="type">int</span>[size_]; &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~Test&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span> data_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> size_;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span>* <span class="title">data_ptr</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> data_;&#125;</span><br><span class="line"></span><br><span class="line">    Test &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Test &amp;other) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;This is copy= operator&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">if</span> (&amp;other != <span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] data_;</span><br><span class="line">            size_ = other.size_;</span><br><span class="line">            data_ = <span class="keyword">new</span> <span class="type">int</span>[size_];</span><br><span class="line">            std::<span class="built_in">copy</span>(&amp;other.data_[<span class="number">0</span>], &amp;other.data_[<span class="number">0</span>] + size_, &amp;data_[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> size_;</span><br><span class="line">    <span class="type">int</span>* data_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Test <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    a = <span class="built_in">Test</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述代码，我们先创建了一个对象a，然后对a通过a &#x3D; Test(10)进行了一次更新。程序输出如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">This is copy= <span class="keyword">operator</span></span><br><span class="line">~Test</span><br><span class="line">~Test</span><br></pre></td></tr></table></figure><p>我们观察输出的结果，这里显然进行了一次内存申请和内存拷贝。仔细思考这个过程，Test(10)首先创建了一个临时对象申请了一块内存，在这条赋值语句执行结束了之后，这个临时的对象生命周期就已经结束了，此时临时对象中的数据也销毁了。进一步思考，总之临时变量在这次运行结束后也会被销毁，我们若能直接把这个临时对象中的资源承接过来转移到a中，似乎就可以减少一次内存申请和拷贝，并且对整个程序来说也是安全的。</p><p>于是，关于赋值，貌似出现了两种选择：</p><ol><li>赋值之后原对象需要保留，此时需要将原对象中的值拷贝到新对象（<strong>拷贝语义 - 拷贝赋值</strong>）</li><li>赋值之后原对象可销毁，此时可以将原对象中的资源转移到新对象并等待原对象销毁（<strong>移动语义 - 移动赋值</strong>）</li></ol><p>显然，一个operator&#x3D;的重载已经没办法满足我们的需求，case 3给出了一个典型的拷贝赋值的实现，显然我们还需要一个移动赋值的实现。要实现这个功能，最重要的是要把上述的两种情况合理表达出来（这涉及到区分原对象是否有保留的价值）。这里c++为了更好地描述类似地情况，引入了<strong>左值和右值</strong>的概念，关于左值右值更详细的描述，可以参考[^2]和[^3]，强烈建议好好读一读。在这里，我们只需要清楚，<strong>在移动语义下，右值才可以在使用完成后直接销毁，承担资源转移的功能</strong>。</p><p>于是，我们可以声明一个Test &amp;operator&#x3D;(Test &amp;&amp;other)函数，来专门处理右值。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Test</span><span class="params">(<span class="type">int</span> size)</span> : size_(size) &#123;</span> data_ = <span class="keyword">new</span> <span class="type">int</span>[size_]; &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~Test&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span>[] data_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> size_; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> *<span class="title">data_ptr</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> data_; &#125;</span><br><span class="line"></span><br><span class="line">    Test &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Test &amp;other) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;This is copy= operator&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">if</span> (&amp;other != <span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] data_;</span><br><span class="line">            size_ = other.size_;</span><br><span class="line">            data_ = <span class="keyword">new</span> <span class="type">int</span>[size_];</span><br><span class="line">            std::<span class="built_in">copy</span>(&amp;other.data_[<span class="number">0</span>], &amp;other.data_[<span class="number">0</span>] + size_, &amp;data_[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Test &amp;<span class="keyword">operator</span>=(Test &amp;&amp;other) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;This is move= operator&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] data_;</span><br><span class="line">            data_ = other.data_;</span><br><span class="line">            size_ = other.size_;</span><br><span class="line">            other.data_ = <span class="literal">nullptr</span>;</span><br><span class="line">            other.size_ = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> size_;</span><br><span class="line">    <span class="type">int</span> *data_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Test <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    a = <span class="built_in">Test</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">This is move= <span class="keyword">operator</span></span><br><span class="line">~Test</span><br><span class="line">~Test</span><br></pre></td></tr></table></figure><p>运行上述代码，我们可以观察到程序执行了移动赋值，资源在两个对象间进行了转移。</p><h2 id="拷贝构造与移动构造"><a href="#拷贝构造与移动构造" class="headerlink" title="拷贝构造与移动构造"></a>拷贝构造与移动构造</h2><p>同理，移动语义与拷贝语义的概念，我们也可以拓展到构造函数上，引入拷贝构造与移动构造的概念。例如对于如下代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Test <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">Test b = a;</span><br><span class="line">Test c = std::<span class="built_in">move</span>(a);</span><br></pre></td></tr></table></figure><p>Test b &#x3D; a的实现需要依赖Test(Test&amp; test)构造函数实现，类似移动赋值，Test c &#x3D; std::move(a)也需要来专门识别右值的构造函数Test(Test&amp;&amp; test)来实现，完整代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Test</span><span class="params">(<span class="type">int</span> size)</span> : size_(size) &#123;</span> data_ = <span class="keyword">new</span> <span class="type">int</span>[size_]; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Test</span>(Test&amp; test): <span class="built_in">size_</span>(<span class="number">0</span>), <span class="built_in">data_</span>(<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;copy construct&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        *<span class="keyword">this</span> = test;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Test</span>(Test&amp;&amp; test): <span class="built_in">size_</span>(<span class="number">0</span>), <span class="built_in">data_</span>(<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;move construct&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        *<span class="keyword">this</span> = test;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Test</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~Test&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span>[] data_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> size_; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> *<span class="title">data_ptr</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> data_; &#125;</span><br><span class="line"></span><br><span class="line">    Test &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Test &amp;other) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;This is copy= operator&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">if</span> (&amp;other != <span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] data_;</span><br><span class="line">            size_ = other.size_;</span><br><span class="line">            data_ = <span class="keyword">new</span> <span class="type">int</span>[size_];</span><br><span class="line">            std::<span class="built_in">copy</span>(&amp;other.data_[<span class="number">0</span>], &amp;other.data_[<span class="number">0</span>] + size_, &amp;data_[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Test &amp;<span class="keyword">operator</span>=(Test &amp;&amp;other) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;This is move= operator&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] data_;</span><br><span class="line">            data_ = other.data_;</span><br><span class="line">            size_ = other.size_;</span><br><span class="line">            other.data_ = <span class="literal">nullptr</span>;</span><br><span class="line">            other.size_ = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> size_;</span><br><span class="line">    <span class="type">int</span> *data_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Test <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    Test b = a;</span><br><span class="line">    Test c = std::<span class="built_in">move</span>(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有兴趣可以自行执行一下上述代码，在这里就不深入讨论了。关于移动构造和拷贝构造更详细的资料可以查看[^4]、[^5]、[^6]和[^7]。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好了，到这里我们可以简单总结一下了：</p><ul><li>移动语义的主要目的就是为了<strong>性能优化</strong>，是为了将一个<strong>即将释放的目标对象</strong>中的资源移动到新对象里，以便<strong>以最小的代价构建新对象</strong>。</li><li>移动语义的相关操作中，被移动的对象在移动后资源已经被移动走，该对象应该被释放或生命周期结束自动释放，<strong>不应有任何后续的操作</strong>。</li><li>c++中的自定义的类原生不支持移动语义，而是通过重载&#x3D;运算符和构造函数来实现的，其核心的原理是在移动语义中，<strong>被移动的对象必须是右值</strong>，因此可以通过重载参数为右值引用的&#x3D;运算符和构造函数，代码在编译过程中就可以根据类型推断来判断释放用户要进行移动操作，具体如何移动是根据用户的实现来进行的。</li><li>对于一个类来说，移动语义相关的函数并不是必须的，<strong>在设计类时若没有显式重载移动语义相关的函数，默认是会直接按照拷贝语义相关的操作来进行的</strong>。</li></ul><h2 id="回过头说一嘴std-move"><a href="#回过头说一嘴std-move" class="headerlink" title="回过头说一嘴std::move"></a>回过头说一嘴std::move</h2><p>到此，我们回过头来再看一下std::move这个操作。在很多移动语义相关的逻辑里我们都能看到std::move的身影。很多文档中都说std::move实际上没有移动任何东西，只是将左值转换为右值。基于上述的一系列讨论，我们似乎更容易理解std::move存在的意义。在代码里，我们可能有很多需要将左值进行移动的操作，移动语义又是通过右值引用作为参数来推断使用哪个构造或者赋值函数的。在这种情况下，std::move将左值类型转换成了右值，进而触发了移动语义相关的构造或者赋值函数。</p><p>因此，std::move相当于只进行了类型转换，真正移动相关的操作还是通过类内部的移动赋值和移动构造函数来实现的。再进一步，假如某一个类自己本身没重载移动赋值和移动构造函数，尽管在一些场景下调用了std::move，相关操作还是会被默认的拷贝函数承接，不会触发任何移动相关的操作。</p><p>[^1]: <a href="https://en.cppreference.com/w/cpp/language/operator_assignment">Assignment operators - cppreference.com</a></p><p>[^2]: <a href="https://en.cppreference.com/w/cpp/language/value_category">Value categories - cppreference.com</a></p><p>[^3]: <a href="https://learn.microsoft.com/zh-cn/cpp/cpp/lvalues-and-rvalues-visual-cpp?view=msvc-170">Lvalues 和 Rvalues (C++)</a></p><p>[^4]: <a href="https://en.cppreference.com/w/cpp/language/move_constructor">Move constructors - cppreference.com</a></p><p>[^5]: <a href="https://en.cppreference.com/w/cpp/language/copy_constructor">Copy constructors - cppreference.com</a></p><p>[^6]: <a href="https://learn.microsoft.com/zh-cn/cpp/cpp/copy-constructors-and-copy-assignment-operators-cpp?view=msvc-170">复制构造函数和复制赋值运算符 (C++)</a></p><p>[^7]: <a href="https://learn.microsoft.com/zh-cn/cpp/cpp/move-constructors-and-move-assignment-operators-cpp?view=msvc-170">移动构造函数和移动赋值运算符 (C++)</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;http://pic.zevzhang.top/blog/images/2022/10/17/b46dcbc57c2e4cbdca32e35541b19689.jpg&quot; title=&quot;Photo by Niranjan _ Photograph on Unsplash&quot;&gt;&lt;/p&gt;
&lt;p&gt;c++11中引入的移动语义和std::move函数，是一个非常容易让人疑惑的点。正好最近在开发中遇到了几个std::move使用不当造成的bug，网上关于移动语义的资料很多，正好借着这个机会，按照我的理解好好盘一盘c++11里的移动语义到底做了一件什么事儿。&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="http://blog.zevzhang.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="c++" scheme="http://blog.zevzhang.top/tags/c/"/>
    
    <category term="编程" scheme="http://blog.zevzhang.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>2021年那些印象深刻的播客节目</title>
    <link href="http://blog.zevzhang.top/2022/02/20/2021%E5%B9%B4%E9%82%A3%E4%BA%9B%E8%AE%A9%E6%88%91%E5%8D%B0%E8%B1%A1%E6%B7%B1%E5%88%BB%E7%9A%84%E6%92%AD%E5%AE%A2%E8%8A%82%E7%9B%AE%E7%9B%98%E7%82%B9/"/>
    <id>http://blog.zevzhang.top/2022/02/20/2021%E5%B9%B4%E9%82%A3%E4%BA%9B%E8%AE%A9%E6%88%91%E5%8D%B0%E8%B1%A1%E6%B7%B1%E5%88%BB%E7%9A%84%E6%92%AD%E5%AE%A2%E8%8A%82%E7%9B%AE%E7%9B%98%E7%82%B9/</id>
    <published>2022-02-20T08:34:08.000Z</published>
    <updated>2021-02-22T14:58:08.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://pic.zevzhang.top/blog/images/2022/01/05/d9db02749544c3a9819a4f12542a6777.jpeg" title="Photo by Amr Taha™ on Unsplash"></p><p>如果说2020年是中文播客爆发的前夜，那2021年一定能算得上是中文播客的元年。</p><p>我虽然算不上是播客的原住民，但也见证了苹果的podcast首页热门节目榜，从相声、段子、英语、郭德纲于谦十年精选，到今天的大内密谈、忽左忽右、日谈公园等一众中文播客的百家争鸣，也见证了小宇宙从内测到上线再到产品功能的不断完善。播客已经成为了我每天上班下班漫长通勤路上的重要组成部分。</p><p>最近总算闲一点了，翻开小宇宙看了一下，过去的一年里听了不少有意思的节目。我关注的频道大体应该可以分为四大类：科技、商业、娱乐、人文社科，去年一年林林总总也收藏了一些有意思的节目，趁着21年还没走远，好好整理了一下2021年那些让我印象深刻的播客节目，这几期节目有的轻松，有的严肃，但都给我带来了很多有价值的启发与思考，其中有些甚至刷了好多遍，在这里简单整理了一下与大家分享。</p><span id="more"></span><h2 id="【凑近点看】VOL-10-我不想重启2020×熊浩：我们该如何反抗脆弱？"><a href="#【凑近点看】VOL-10-我不想重启2020×熊浩：我们该如何反抗脆弱？" class="headerlink" title="【凑近点看】VOL 10 - 我不想重启2020×熊浩：我们该如何反抗脆弱？"></a>【凑近点看】<a href="https://www.xiaoyuzhoufm.com/episode/5feaeef2dee9c1e16df53c15?s=eyJ1IjogIjVmODFlMjhjZTBmNWU3MjNiYjk2MTc3YSJ9">VOL 10 - 我不想重启2020×熊浩：我们该如何反抗脆弱？</a></h2><p><img src="http://pic.zevzhang.top/blog/images/2022/01/13/4fccb60a35066bd9751f3569ae696b4f.png"></p><p>这期节目是2020年12月29日的节目，原本应该算是20年的节目，但我听到这期节目的时候已经是2021年1月，姑且也算到2021年的节目盘点里吧～～</p><p>这期是真的宝藏，几个主播一边插科打诨，氛围非常轻松，同时又强烈输出，话题深度与信息密度极高，每次听都会收获一些新的感悟。尤其是熊浩老师的关于学习，关于跟自己相处，关于人生规划的思考，给了我非常大的触动。</p><p>顺带说一句，几个主播也太会聊天了，观点输出非常流畅，语言表达非常舒服。像“如果能重来，奋不顾身也不并不珍贵，孤注一掷也不并不壮烈”、“我开始懂得了古人为什么要闭关，就是要用慢的流速让自己能够不断地降落和堆叠”，整期节目随便摘出来一段对话都是这样的金句。</p><p>年度最佳！！强烈推荐！！</p><h2 id="【声东击西】-196-请收下这枚记录-2021-年的声音时光胶囊"><a href="#【声东击西】-196-请收下这枚记录-2021-年的声音时光胶囊" class="headerlink" title="【声东击西】#196 请收下这枚记录 2021 年的声音时光胶囊"></a>【声东击西】<a href="https://www.xiaoyuzhoufm.com/episode/61cba58a77c2fd938c5ece0a?s=eyJ1IjogIjVmODFlMjhjZTBmNWU3MjNiYjk2MTc3YSJ9">#196 请收下这枚记录 2021 年的声音时光胶囊</a></h2><p><img src="http://pic.zevzhang.top/blog/images/2022/01/13/84af1fe5fb226ee5e7e4727d53b7c922.png"> </p><p>我应该能算得上声东击西的老粉丝了，时光胶囊系列是我非常喜欢的一个系列，用声音去回顾一整年是一个不错的体验。说实话，从我个人角度我认为21年的声音胶囊略逊色于20年的，21年的盘点多了很多时政大事，少了些小人物在大时代背景下的声音，尽管如此却不妨碍这是一期好节目。</p><p>21年已经是与疫情共处的第二个年头了，来回反复的疫情似乎加快了时间前进的节奏，模糊了我们对时间的感知。一边听着这期节目中的声音，一边感慨声音背后的事件仿佛都还发生在昨天一样，等节目听完才恍惚发现，原来2021年，我们经历并见证了这么多大事。</p><p>非常赞的节目，推荐大家闲暇的时候听一听，用声音带着自己回顾整个2021。</p><h2 id="【贝望录】48-谁说葡萄酒不能兑汽水"><a href="#【贝望录】48-谁说葡萄酒不能兑汽水" class="headerlink" title="【贝望录】48. 谁说葡萄酒不能兑汽水"></a>【贝望录】<a href="https://www.xiaoyuzhoufm.com/episode/609b1a8e6b7c6f99ebc4c35e?s=eyJ1IjogIjVmODFlMjhjZTBmNWU3MjNiYjk2MTc3YSJ9">48. 谁说葡萄酒不能兑汽水</a></h2><p><img src="http://pic.zevzhang.top/blog/images/2022/01/13/42ab3f333c208d0adf7ed3e914df7575.jpeg"></p><p>贝望录是我每期必追的播客频道，非常喜欢Bessie老师轻松幽默的风格，同时也拓宽了自己很多的商业知识。聊葡萄酒这期是我个人非常非常喜欢的一期，作为一个定期馋酒的小酒鬼，听着嘉宾凤仪老师操着一嘴蹩脚中文，但又如此接地气地跟大家聊葡萄酒，简直是无比轻松享受的过程。</p><p>喝酒本就应该是一件轻松的事儿，抛开那些乱七八糟的规矩吧，就像凤仪老师说的，“如果你没有那么多（葡萄酒的）知识，你反而会更开放地喝酒“。所以，谁说葡萄酒不能兑汽水？</p><h2 id="【子非鱼】子非鱼E64-三人聊《三体》：影视剧，历史书，博弈论？"><a href="#【子非鱼】子非鱼E64-三人聊《三体》：影视剧，历史书，博弈论？" class="headerlink" title="【子非鱼】子非鱼E64 | 三人聊《三体》：影视剧，历史书，博弈论？"></a>【子非鱼】<a href="https://www.xiaoyuzhoufm.com/episode/618e5e69ec933f52be85807c?s=eyJ1IjogIjVmODFlMjhjZTBmNWU3MjNiYjk2MTc3YSJ9">子非鱼E64 | 三人聊《三体》：影视剧，历史书，博弈论？</a></h2><p><img src="http://pic.zevzhang.top/blog/images/2022/01/13/c4674a9517fb509821ec7761c5959c14.png"></p><p>这期子非鱼聊的《三体》，是我近年来听过的关于三体这本书聊的非常深入的一期的节目。</p><p>第一次接触《三体》还是在高中时蹭同桌的《科幻世界》，后来大一时间空闲了，陆陆续续把《三体》三部全部读完后，彻底被大刘圈粉。这期的子非鱼，三个主播从很多新的角度聊了聊读《三体》的感触，就像Gareth开篇破题时说的：“……各自的经历或者职业比较大……大家应该各自能从三体里收获到自己比较想要的，或者特别有感触的东西”</p><p>“一千个读者心中有一千个哈姆雷特”，一千个读三体的读者中，应该也有一千份读《三体》的收获吧。</p><p>PS: 祝乾亮老师的三体系列真的太赞了！</p><h2 id="【贝望录】61-把茶叶卖给年轻人有多难？"><a href="#【贝望录】61-把茶叶卖给年轻人有多难？" class="headerlink" title="【贝望录】61. 把茶叶卖给年轻人有多难？"></a>【贝望录】<a href="https://www.xiaoyuzhoufm.com/episode/611c4da29edcaf59e47aaf21?s=eyJ1IjogIjVmODFlMjhjZTBmNWU3MjNiYjk2MTc3YSJ9">61. 把茶叶卖给年轻人有多难？</a></h2><p><img src="http://pic.zevzhang.top/blog/images/2022/01/13/42ab3f333c208d0adf7ed3e914df7575.jpeg"></p><p>贝望录又上榜了～～</p><p>我曾经跟朋友们开玩笑说，如果我要去创业的话，我一定会去卖那些成瘾性高的产品，比如咖啡、酒饮料或者茶。然而冷静想一想，无论是咖啡还是酒饮料，最近两年相关赛道都越来越火热，但反观茶饮类，除了勉强能被算到含茶饮料的果茶、奶茶这两年杀疯了以外，传统的茶类赛道看上去还是保持着老样子，很难有新的突破，年轻人也似乎离茶叶越来越远。</p><p>这期贝望录从茶行业的发展、茶叶在年轻人中的普及等方面，输出了很多值得思考的观点。其中有一点，关于年轻人与历史的话题上，嘉宾的观点让我感触非常大，茶叶的本质首先是消费品，“如果我们把茶叶当成一种历史的载体来看，我们当然希望文化被继承，但是我们不希望它被这么沉重地被继承”。非常赞同嘉宾的观点，我们身边与传统文化相关的食物似乎都被背负了太多历史载体的使命，反而越来越难被年轻人接受。如同嘉宾所说的“如果让一款产品能普及到千家万户，你应该用最简单的方法去做，而不是用最复杂的方法去做”，放下历史的包袱，先把这些传承当作一个产品，从产品角度来思考怎么服务好当前用户的需求，可能是一种更好的继承方式吧。</p><h2 id="【乱翻书】-Vol-26-Web2-0-VS-Web3-0，对方辩友请发言（上）-Vol-27-Web2-0-VS-Web3-0，对方辩友请发言（下）"><a href="#【乱翻书】-Vol-26-Web2-0-VS-Web3-0，对方辩友请发言（上）-Vol-27-Web2-0-VS-Web3-0，对方辩友请发言（下）" class="headerlink" title="【乱翻书】 Vol.26 Web2.0 VS Web3.0，对方辩友请发言（上）  || Vol.27 Web2.0 VS Web3.0，对方辩友请发言（下）"></a>【乱翻书】 <a href="https://www.xiaoyuzhoufm.com/episode/61bb8cf5898eaed596507419?s=eyJ1IjogIjVmODFlMjhjZTBmNWU3MjNiYjk2MTc3YSJ9">Vol.26 Web2.0 VS Web3.0，对方辩友请发言（上）</a>  || <a href="https://www.xiaoyuzhoufm.com/episode/61bb8e6a1773c5744af3f18a?s=eyJ1IjogIjVmODFlMjhjZTBmNWU3MjNiYjk2MTc3YSJ9">Vol.27 Web2.0 VS Web3.0，对方辩友请发言（下）</a></h2><p><img src="http://pic.zevzhang.top/blog/images/2022/01/13/0aaa064784d8650fa6f02ed8bde864d5.png"></p><p>潘乱老师的乱翻书是我非常喜欢的播客频道。乱翻书的大部分节目都是直播的声音版，很多嘉宾都是直接连麦过来的，录音质量说实话是真心差，声音比较糊，但盖不住内容赞，讨论的观点深刻又犀利，干货量非常高，强烈建议潘乱老师好好升级一下录音设备，多录一些线下节目。</p><p>这两期节目是一段讨论的上下半场，潘乱老师找来了一帮大佬，基本上分成了两个阵营来聊Web3.0。内容上说实话聊的有些松散，有一大段时间似乎嘉宾们有点自己聊自己的、频繁抛概念的感觉，同时内容专业度可能比较高，对于听众来说，能跟上嘉宾的节奏也需要提前储备一大波Web3.0的知识。尽管如此，我依旧选了这期节目，难得听到了一期如此深入聊Web3.0的节目。去年随着元宇宙、Web3.0这一波概念火了之后，我陆续听了好多标榜科技类播客的频道，云里雾里地跟风聊了一波Web3.0，内容也毫无新意，基本上都是在鼓吹Web3.0、元宇宙的美好愿景。这期节目我很欣喜地听到了不同的声音，听到了大佬们是对这些概念的解读，也听到了一些非常深入的思考与感悟。</p><p>另外，金叶宸老师后来还在三五环录了一期Web3.0的内容，由于不是辩论而是对谈的形式，观点表达地更清晰一点，顺手也放上链接：<a href="https://www.xiaoyuzhoufm.com/episode/61d5aa50ee197a3aac3dac8a?s=eyJ1IjogIjVmODFlMjhjZTBmNWU3MjNiYjk2MTc3YSJ9">No.58 跟金叶宸聊聊 Web3 和元宇宙</a></p><p>哦对了， 这一期的乱翻书，音质依旧感人……</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一波整理下来，发现2021年真的听了很多高质量的节目了，同时也很开心看到越来越多人开始录制自己的播客，尤其是小宇宙上线了首页推荐了之后，陆续听到了好多有意思的节目。在整理的过程中，我也回听了好多期被我点赞了之后就忘到箱底的节目，确实有一些优秀的内容值得好好记录整理一下。</p><p>2022年，我琢磨着搞个啥形式，定期把自己听过的节目，整理记录一下，可能是听后的感悟，或者是内容要点整理，总之借此写点东西，目前先放到这里吧。也希望2022年，能有更多的新的收获与体验。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;http://pic.zevzhang.top/blog/images/2022/01/05/d9db02749544c3a9819a4f12542a6777.jpeg&quot; title=&quot;Photo by Amr Taha™ on Unsplash&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果说2020年是中文播客爆发的前夜，那2021年一定能算得上是中文播客的元年。&lt;/p&gt;
&lt;p&gt;我虽然算不上是播客的原住民，但也见证了苹果的podcast首页热门节目榜，从相声、段子、英语、郭德纲于谦十年精选，到今天的大内密谈、忽左忽右、日谈公园等一众中文播客的百家争鸣，也见证了小宇宙从内测到上线再到产品功能的不断完善。播客已经成为了我每天上班下班漫长通勤路上的重要组成部分。&lt;/p&gt;
&lt;p&gt;最近总算闲一点了，翻开小宇宙看了一下，过去的一年里听了不少有意思的节目。我关注的频道大体应该可以分为四大类：科技、商业、娱乐、人文社科，去年一年林林总总也收藏了一些有意思的节目，趁着21年还没走远，好好整理了一下2021年那些让我印象深刻的播客节目，这几期节目有的轻松，有的严肃，但都给我带来了很多有价值的启发与思考，其中有些甚至刷了好多遍，在这里简单整理了一下与大家分享。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="http://blog.zevzhang.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="盘点" scheme="http://blog.zevzhang.top/tags/%E7%9B%98%E7%82%B9/"/>
    
    <category term="播客" scheme="http://blog.zevzhang.top/tags/%E6%92%AD%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>在后厂的二三事儿</title>
    <link href="http://blog.zevzhang.top/2021/12/31/%E5%9C%A8%E5%90%8E%E5%8E%82%E7%9A%84%E4%BA%8C%E4%B8%89%E4%BA%8B%E5%84%BF/"/>
    <id>http://blog.zevzhang.top/2021/12/31/%E5%9C%A8%E5%90%8E%E5%8E%82%E7%9A%84%E4%BA%8C%E4%B8%89%E4%BA%8B%E5%84%BF/</id>
    <published>2021-12-31T09:12:01.000Z</published>
    <updated>2021-12-31T09:12:01.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://pic.zevzhang.top/blog_img/20210819183709.jpeg" title="宇宙中心后厂村"></p><p>北京时间2021年12月31日，在朋友圈开始疯转2021年年终总结的时候，我突然觉得是不是自己也该动手写点什么呢？于是，在参加完公司的新年活动之后，在一片浓浓的划水气氛中，我在hexo上拉了一个新的post，准备写点东西。</p><span id="more"></span><p>要对2021年总结啦，写点啥的呢？今年经历的大事吗？搬家？度蜜月？准爸爸？工作顺利？工作不顺利？似乎有很多要记录要总结的，似乎又都不值得写下来。</p><p>我其实骨子里是一个挺爱吹牛逼的性格，我甚至觉得跟一群人喝酒侃大山是一件非常惬意的事。但是，当我准备跟风写个年终总结的时候，我发现，我确实不擅长写东西。</p><p>说一个最近的事儿吧，前几天跟朋友吃饭，大家聊起特斯拉股价，朋友说特斯拉的市值已经比头部的十大传统车企市值总和还要高了。作为当时在场唯一一个曾经高位持有特斯拉股票，并稳稳地在低位抛掉，然后看着它飙升到1000多的韭菜，我深信我对这个话题有一定的发言权。于是，我开始滔滔不绝地侃起我对特斯拉估值的理解，我列举了很多马斯克的个人魅力，例如煽动力有多强，执行力有多强，想法有多超前云云，也摆了很多特斯拉在造车方面的优势，比如智能化做的多么好，电池技术有多么牛逼，驾驶体验有多么赞，外形设计有多么科技等等。</p><p>等我侃完，朋友问了我一个问题，所以你说了这么多，到底为什么它的市值能到这么高？</p><p>对啊，我似乎只是说了一些主观上的感受，但仅仅只是因为这些就能让特斯拉估值到传统车企的十倍吗？我貌似并没有深入思考清楚这个问题，更严重的是，在回答这个问题的时候，我根本没有抓住问题的核心。我的逻辑链似乎是：因为马斯克牛，所以特斯拉造的车牛，所以特斯拉公司的市值就应该有这么高。但是，这个逻辑本身就是有问题的。后来，我花了一中午的时间，调研了各个研究机构对特斯拉的未来估值分析报告，也大体扫了一下特斯拉的财报，我发现我对特斯拉有了一个新的认识，它的高估值并不是仅仅是因为车造的好，还来自于它近乎夸张的成本控制，在自动驾驶、Robotaxi超前的布局，软件生态的未来的营收预期，还有大众对电动车市场巨大增长空间的看好。</p><p>这件事儿后，我自我反思了一下，我其实性格里是一个比较疏懒的人，“好求知而不求甚解”（此处并不是褒义词）似乎已经成了常态，对很多事物的理解上可能太理所当然地以为事情就是想当然的样子，在没思考清楚事情的本质之前，就急着去表达。思维是存在惰性的，在当下这个浮躁的环境里，深入思考貌似比表达更有价值；当然，高质量的表达也是需要训练的，逻辑清晰的表达是建立在深入思考的基础上，表达也是让思考释放价值有效途径。</p><p>于是，在2021年的最后一周，我整理了这个无人问津的博客。一方面想给表达找个出口，另一方面也希望督促自己深入思考，好好说话。未来这个博客，可能陆续更新一些文章，但估计频率不会太高，在这块属于自己的角落里，写一些生活的琐事感悟，记录一些自己的学习笔记，还有自己的一些反思总结，也希望给自己找一个交流分享的渠道。关于起名字上，我想了很多个老气横秋的名字，比如“静思录”，“思过录”，“思己斋”，想来想起还是算了吧，一方面以我的文化水平和表达能力，写下的狗屁文章会与名字之间产生巨大的违和感，另一方面本来就是记录生活和思考的笔记，犯不上非得拔高到多高的高度。鉴于目前且未来一段时间，可能都会在后厂附近绕来绕去，索性直接就叫“后厂村的二三事儿”吧。</p><p>好吧，扯了这么多，我貌似是要写个年终总结来着吧？多少还是写几句吧，2021年，对我来说可能经历了非常长的一段时间的浮躁期，同时也经历了很多让自己成长的事儿，真真切切让自己成长的事儿。想起13年去台湾社会实践，在打狗领事馆的参观的时候，那边有个投币抽签算卦的机器，我至今仍清楚的记得我抽到的卦辞：“意中若问神仙路，劝尔且退望高楼。宽心且守宽心坐，必然遇得贵人扶”。2021年底，再回忆起来感触良多。</p><p>最后的最后，2022年，希望自己诸事顺遂～～</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;http://pic.zevzhang.top/blog_img/20210819183709.jpeg&quot; title=&quot;宇宙中心后厂村&quot;&gt;&lt;/p&gt;
&lt;p&gt;北京时间2021年12月31日，在朋友圈开始疯转2021年年终总结的时候，我突然觉得是不是自己也该动手写点什么呢？于是，在参加完公司的新年活动之后，在一片浓浓的划水气氛中，我在hexo上拉了一个新的post，准备写点东西。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="http://blog.zevzhang.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="扯扯淡" scheme="http://blog.zevzhang.top/tags/%E6%89%AF%E6%89%AF%E6%B7%A1/"/>
    
  </entry>
  
  <entry>
    <title>【论文笔记】LambdaOpt:Learn to Regularize Recommender Models in Finer Levels</title>
    <link href="http://blog.zevzhang.top/2019/10/18/%E3%80%90%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0%E3%80%91LambdaOpt-Learn-to-Regularize-Recommender-Models-in-Finer-Levels/"/>
    <id>http://blog.zevzhang.top/2019/10/18/%E3%80%90%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0%E3%80%91LambdaOpt-Learn-to-Regularize-Recommender-Models-in-Finer-Levels/</id>
    <published>2019-10-18T07:49:12.000Z</published>
    <updated>2024-12-23T06:36:40.229Z</updated>
    
    <content type="html"><![CDATA[<img src="http://pic.zevzhang.top/image/lambda_opt/lambda_opt.png" alt="github大法好！"/><blockquote><p>最近调研自动调参相关技术的时候发现了这篇今年KDD的文章，论文提出了一种细粒度自动化调整正则化参数的方法，在此记录一下学习笔记。</p></blockquote><hr><span id="more"></span><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在推荐系统相关技术中，类别型往往比连续性变量更常见，对于这种类别型变量，通常我们将其通过one-hot方式表示，来接入后续的LR、MF等模型。然而在工业场景中，这种类型的变量通常都对模型很不友好，比如高维、长尾分布等，这些特性会带来严重的数据稀疏性问题。为了避免数据稀疏性对模型效果的影响，产业界中大部分的线上模型都加入了正则化，来压制数据的稀疏性问题。</p><p>引入正则化就带来头疼的正则化参数调整的问题，很多推荐模型都会对正则化参数非常敏感，作者给出了一个例子来说明，在矩阵分解模型中，lambda的调整会对模型效果产生较大影响：</p><p><img src="http://pic.zevzhang.top/image/lambda_opt/lambda_opt_motivation.png"></p><p>简单来说，作者认为<strong>传统结构下对正则化系数进行调参十分困难</strong>，主要导致其困难的主要原因是因为：</p><ol><li>全局统一的lambda不能兼顾训练的前后阶段。（lambda较大能照顾到出现频率高的样本特征，忽视较低的样本特征）</li><li>若使用更为细粒度的正则化参数，则超参太多不易调整。（grid search这些方法，不适合推荐系统这种实时性较高、数据规模较大的应用场景）</li></ol><p>因此，这篇文章核心关注的问题，就是<strong>如何自动化地调教正则系数</strong>。</p><p>文章总结了自动化正则化地相关工作：</p><ol><li>SGDA模型</li><li>网格搜索（grid-search）、贝叶斯优化、架构搜索（Neural Architecture Search）</li><li>embedding正则化</li></ol><p>以上的方法都存在着一定的问题导致不是特别适用于推荐系统中。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="带正则化的MF-BPR模型"><a href="#带正则化的MF-BPR模型" class="headerlink" title="带正则化的MF-BPR模型"></a>带正则化的MF-BPR模型</h3><p>文章主要针对矩阵分解（MF）为基础模型，loss函数为BPR（Bayesian Personalized Ranking）进行讨论。带正则化参数的MF模型，损失函数可以看作两部分，一部分是模型本身的BPR损失，另一部分为正则化损失。如下图所示，总的loss fuction由两部分组成，一部分是没有正则化的MF-BPR损失，另一部分为在得到当前参数时，正则化系数为lambda的正则化损失。下图是采用全局固定lambda参数时损失函数的表示情况：</p><p><img src="http://pic.zevzhang.top/image/lambda_opt/lambda_opt_old.png"></p><h3 id="Lambda-OPT方法"><a href="#Lambda-OPT方法" class="headerlink" title="Lambda OPT方法"></a>Lambda OPT方法</h3><h4 id="MF-BPR模型动态正则化方法"><a href="#MF-BPR模型动态正则化方法" class="headerlink" title="MF-BPR模型动态正则化方法"></a>MF-BPR模型动态正则化方法</h4><p>既然传统的方法中，lambda在训练阶段时全局固定的，那么原始问题的就是一个简单的loss函数最小化问题。但文章中说明了，采用动态的lambda能够兼顾训练的不同阶段，因此loss最小化就不是一个简单的单参数最小化问题，相当于除了模型参数$\theta$外，模型还引入了正则化参数$\Lambda$，在训练的过程中对这两个参数都要进行学习。模型整体结构如下，即不再采用全局统一的lambda，而单独针对不同的部分选择不同的lambda。</p><p><img src="http://pic.zevzhang.top/image/lambda_opt/lambda_opt_now.png"></p><h4 id="双层优化问题"><a href="#双层优化问题" class="headerlink" title="双层优化问题"></a>双层优化问题</h4><p>如何在训练阶段同时对这两个参数都进行优化呢？作者将改问题看作一个<strong>双层优化问题</strong>。既然loss函数可以分为两部分，那么原始loss最小化问题，可以表示为如下所示的MinMin问题，具体公式如下所示：</p><p><img src="http://pic.zevzhang.top/image/lambda_opt/lambda_opt_gongshi2.png"></p><p>对如上公式进行优化，文章设计了一种交替优化的策略。首先固定$\Lambda_t$，在训练集上优化一步$\theta$。接着固定此时的$\theta_t$，优化$\Lambda$。在优化$\Lambda$阶段，文章采取了一种贪婪的策略，即让新的$\Lambda$能够使模型下一步的validation loss比较小。具体流程如下：</p><ol><li>首先首先固定$\Lambda_t$，在训练集上sample一个batch，计算梯度，更新后得到下一步的$\theta_{t+1}$</li><li>得到$\theta_{t+1}$后，优化 $\min \limits_{\Lambda} l_{S_v}\left ( \overline{\theta}<em>{t+1} \right )$ （此时要求$\Lambda$非负），在测试集上sample一个batch，固定$\theta</em>{t+1}$，更新$\Lambda_{t+1}$</li></ol><p>其中$\min \limits_{\Lambda} l_{S_v}\left ( \overline{\theta}_{t+1} \right )$要保证$\Lambda \geq 0$。文章也进行了推导，给出了KKT条件。</p><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>实验在Amazon Food数据集和MovieLenss 10M数据集上做的，通过作者的分析可以看出，这些数据集具有很明显的长尾分布。从paper上来看，效果提升还是很明显的：</p><p><img src="http://pic.zevzhang.top/image/lambda_opt/lambda_opt_exp.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>文章中重要的部分都在这里了，其他的关于实验和一些推导就不再赘述了。文章实际想解决的问题是如果在训练的过程中，在不同阶段自动化地采取不同地正则化系数，来保证正则化地惩罚项能够兼顾训练地前后阶段。文章为了解决这个问题，首先将$\Lambda$看做是一个参数，然后对模型参数$\theta$和$\Lambda$采用交替训练的策略。个人感觉，这个思路还是挺直接粗暴的，我最近工作也涉及到了一些自动化调参相关的工作，也基本上采用的是类似的方法，但是作者的一些小trick，比如在训练集上训练$\theta$而在验证集上调整$\Lambda$，再比如模拟前进一步$\theta$的贪婪方法来调整$\Lambda$，还是很有借鉴价值的。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol><li><a href="https://arxiv.org/abs/1905.11596">论文地址</a></li><li><a href="https://zhuanlan.zhihu.com/p/80056815">λ优化——学习细粒度正则化推荐模型 – yich 知乎</a></li><li>作者本人在bilibili上的直播分享：<a href="https://www.bilibili.com/video/av69058047?from=search&seid=16281801102652432221">KDD 2019论文分享丨 LambdaOpt:Learn to Regularize Recommender Models in Finer Levels</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;http://pic.zevzhang.top/image/lambda_opt/lambda_opt.png&quot; alt=&quot;github大法好！&quot;/&gt;

&lt;blockquote&gt;
&lt;p&gt;最近调研自动调参相关技术的时候发现了这篇今年KDD的文章，论文提出了一种细粒度自动化调整正则化参数的方法，在此记录一下学习笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="papers" scheme="http://blog.zevzhang.top/categories/papers/"/>
    
    
    <category term="论文笔记" scheme="http://blog.zevzhang.top/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    <category term="推荐系统" scheme="http://blog.zevzhang.top/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>API Blutprint: RESTful接口文档设计工具配置</title>
    <link href="http://blog.zevzhang.top/2017/11/17/API-Blutprint-RESTful%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3%E8%AE%BE%E8%AE%A1%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/"/>
    <id>http://blog.zevzhang.top/2017/11/17/API-Blutprint-RESTful%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3%E8%AE%BE%E8%AE%A1%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/</id>
    <published>2017-11-17T09:11:59.000Z</published>
    <updated>2024-12-23T06:26:56.764Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://pic.zevzhang.top/blog/gongchengshi.jpeg"></p><hr><span id="more"></span><p>目前主流web程序架构中，为了尽量降低前后端的耦合性，大多选择将前后端分离设计，前后端通过RESTful接口进行数据交互。这种设计方案的好处不用太多赘述，但需要项目在开发前编写一个具有较高可读性的接口设计文档，这样前后端在进行开发的时候就可以参考项目设计文档设计自己的模块，降低交流的成本。</p><p>作为一个自封的实验室攻城狮，编写设计文档一直都是一件让自己十分抓头发的事，不是编出来可读性差，就是花很多精力与时间磨一个设计文档，于是为了编写出更高质量的设计文档（其实主要动力是懒），一直在寻觅一个好用的RESTful接口文档设计工具。直到偶然发现了<a href="https://apiblueprint.org/">API Blueprint</a>这款工具，甚合朕意~~</p><p>API Blueprint使用Markdown来编写API文档，然后可以直接生成一个漂亮的html页面，这样就可以专注于文档的内容，不用为了提高可读性而过多在排版上花费太多精力，简直是懒癌晚期程序员的福音！</p><p>下面上干货了，关于如何配置这个东西呢，其实简单应用的话并不复杂，一方面要配置一下一个好用的编辑环境，另一方面要把API Blueprint的解析环境配置好。主要的配置过程参考了Lulee007的文章：<a href="http://devlu.me/2016/05/05/write-restful-api-doc-with-apiblueprint/">使用 API BluePrint 编写 RESTful 接口文档</a>。</p><h2 id="编辑环境的配置"><a href="#编辑环境的配置" class="headerlink" title="编辑环境的配置"></a>编辑环境的配置</h2><p>Lulee007里主要介绍了atom的配置方法，atom插件功能更强大一些，同时atom的插件里还有一个叫做api-blueprint-preview的插件可以用来预览导出，习惯atom的孩纸可以用这个。</p><p>我个人用vscode比较多，其实API Blueprint就是用markdown来编写API文档，内容是服从markdown语法的，因此只要让vscode识别出*.apib文件（API Blueprint文件的后缀名），将这种类型的文件应用markdown语法高亮就可以了。vscode的插件库里有一款叫做API Blueprint Language的插件，安装好了之后就支持apib文件的高亮了。</p><p>但是vscode中貌似不可以使用预览功能来查看Blueprint的效果，不过没关系，aglio可以直接在本地启动一个server在浏览器里看效果。</p><h2 id="aglio的配置"><a href="#aglio的配置" class="headerlink" title="aglio的配置"></a>aglio的配置</h2><p>aglio是Blueprint的解析环境，是一个node.js编写的程序，安装之前需要先配置好node.js，直接使用npm安装就可以：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g aglio</span><br></pre></td></tr></table></figure><h3 id="浏览器查看效果"><a href="#浏览器查看效果" class="headerlink" title="浏览器查看效果"></a>浏览器查看效果</h3><p>对于一个apib文件，如果想看这个文件的效果，可以在终端里输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aglio -i testrestapi.apib -s</span><br></pre></td></tr></table></figure><p>有时候可能需要root权限，出现permission deny的错误的时候加sudo运行就可以了。效果如下：</p><p><img src="http://pic.zevzhang.top/blog/xiaoguo.png"></p><h3 id="生成html"><a href="#生成html" class="headerlink" title="生成html"></a>生成html</h3><p>尽管应用aglio工具可以将apib文件转化为漂亮的浏览器页面，但是这样的方式显然是不便于流通的，并不是每个人电脑上都配置里aglio工具的，最好能把apib转为为可读性更高的html页面。aglio工具提供了这样的功能。在终端输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aglio -i testrestapi.apib -o testapi.html</span><br></pre></td></tr></table></figure><p>即可生成一个名为testapi.html的网页文件。</p><h2 id="API-Blueprint的语法与高级功能"><a href="#API-Blueprint的语法与高级功能" class="headerlink" title="API Blueprint的语法与高级功能"></a>API Blueprint的语法与高级功能</h2><p>一个完整的 API BluePrint 文档要包括以下部分(带*为必须有)：</p><ul><li>Metadata section 元数据部分*</li><li>API name &amp; overview section API 名称和说明部分*</li><li>Resource group section 资源组部分</li><li>Resource section 资源部分*</li><li>Resource model section 资源模型部分</li><li>Schema section</li><li>Action section 动作部分*</li><li>Request section 请求*</li><li>Response section 相应*</li><li>URI parameters section 请求 URL 参数</li><li>Attributes section 属性部分</li><li>Headers section HTTP Headers 部分</li><li>Body section HTTP Body 部分*</li><li>元数据 Metadata</li></ul><p>具体的语法规则可以看<a href="https://github.com/apiaryio/api-blueprint/blob/master/API%20Blueprint%20Specification.md">API Blueprint文档</a>与<a href="http://devlu.me/2016/05/05/write-restful-api-doc-with-apiblueprint/">Lulee007</a>博客中的说明。关于样例方面，官方的github里有一个很全面的<a href="https://github.com/apiaryio/api-blueprint/tree/master/examples">example文件夹</a>，照着读一读语法就差不读了。Lulee007在自己的github上也放了一个<a href="https://gist.github.com/lulee007/ace3439635fd950f2644b645dac54425">样例</a>，很全面的一个apib的文档，基本上大部分接口文档都可以照着这个改一改。</p><p>除此之外，aglio还支持很多不同的主题，比如生成三栏的页面：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo aglio -i testrestapi.apib --theme-template triple -o output.html</span><br></pre></td></tr></table></figure><p><img src="http://pic.zevzhang.top/blog/trib.png"></p><p>生成黑色主题的页面：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo aglio --theme-variables slate -i testrestapi.apib -o output.html</span><br></pre></td></tr></table></figure><p><img src="http://pic.zevzhang.top/blog/black_theme.png"></p><p>更详细的功能参数可以参考<a href="https://github.com/danielgtaylor/aglio">aglio的github</a>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/apiaryio/api-blueprint/blob/master/API%20Blueprint%20Specification.md">API Blueprint文档</a></li><li><a href="http://devlu.me/2016/05/05/write-restful-api-doc-with-apiblueprint/">使用 API BluePrint 编写 RESTful 接口文档 –Lulee007</a></li><li><a href="https://github.com/danielgtaylor/aglio">aglio的github</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;http://pic.zevzhang.top/blog/gongchengshi.jpeg&quot;&gt;&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="工程" scheme="http://blog.zevzhang.top/categories/%E5%B7%A5%E7%A8%8B/"/>
    
    
    <category term="工程" scheme="http://blog.zevzhang.top/tags/%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Spring框架中调用HanLP分词的方法</title>
    <link href="http://blog.zevzhang.top/2017/10/06/Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E8%B0%83%E7%94%A8HanLP%E5%88%86%E8%AF%8D%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://blog.zevzhang.top/2017/10/06/Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E8%B0%83%E7%94%A8HanLP%E5%88%86%E8%AF%8D%E7%9A%84%E6%96%B9%E6%B3%95/</id>
    <published>2017-10-06T02:00:40.000Z</published>
    <updated>2024-12-22T07:02:21.596Z</updated>
    
    <content type="html"><![CDATA[<img src="http://img5.cache.netease.com/lady/2016/3/17/2016031715274740f10.jpg" width = "400" alt="豌豆镇楼"/><p>豌豆镇楼</p><hr><p>事情是这样的，最近实验室在搞一个Java Web的项目，用的Spring MVC的框架。项目组有很多没做过Spring的学弟学妹，为了提高效率，我让大家自己先抛开Spring来写自己负责的模块，我来把各个模块在Spring里集成。</p><span id="more"></span><p>项目里有一个文本分析的模块是一个学妹负责的，里面用到了HanLP，我在集成的时候直接用maven添加的依赖，等集成好了测试的时候发现怎么也测不过，问了学妹才发现为了做实体识别，她用了一个很鸡贼的方法，自己改了HanLP的词典，手动加了好多词，而且后期版本迭代中还有可能继续改。。。。</p><p>改了HanLP的词典就意味着不能用maven直接导入仓库里的包了，只能直接将修改后的data文件放到本地，然后指定路径给HanLP。搜了一下网上很多方法，都是在项目部署的时候，把HanLP的词典数据放到服务器上一个固定位置上，然后再配置HanLP的配置文件，指定一个固定位置。这种方法虽然直接，但是不能把HanLP的词典数据跟整个项目打包到一起，管理起来很麻烦。倘若把数据直接作为项目的资源文件，部署到Tomcat上后无论怎么在配置里写路径都会提示找不到词典文件。研究了一下HanLP的issue之后，我发现这个项目支持自定义读写文件的IO类。在一个将词典数据放到HDFS上的一个blog启发下，我想了一个很鸡贼的方法，我重写一个IOAdapter类，使用读写静态资源文件的方法读取词典数据了，这样不就可以把data跟项目打包到一起了嘛。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.car.util.nlp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hankcs.hanlp.corpus.io.IIOAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.ClassPathResource;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResourcesFileIoAdapter</span> <span class="keyword">implements</span> <span class="title class_">IIOAdapter</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> InputStream <span class="title function_">open</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ClassPathResource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(path);</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(resource.getFile());</span><br><span class="line">        <span class="keyword">return</span> is;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> OutputStream <span class="title function_">create</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        <span class="type">ClassPathResource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(path);</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(resource.getFile());</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>整好了之后把data文件夹和hanlp.properties放到项目的资源文件夹里，在配置文件里修改一下路径和IOAdapte：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root=</span><br><span class="line"></span><br><span class="line">IOAdapte=com.car.util.nlp.ResourcesFileIoAdapter</span><br></pre></td></tr></table></figure><p>不知道正确的解决方案应该是啥，感觉这个方法还是很鸡贼的。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;http://img5.cache.netease.com/lady/2016/3/17/2016031715274740f10.jpg&quot; width = &quot;400&quot; alt=&quot;豌豆镇楼&quot;/&gt;

&lt;p&gt;豌豆镇楼&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;事情是这样的，最近实验室在搞一个Java Web的项目，用的Spring MVC的框架。项目组有很多没做过Spring的学弟学妹，为了提高效率，我让大家自己先抛开Spring来写自己负责的模块，我来把各个模块在Spring里集成。&lt;/p&gt;</summary>
    
    
    
    <category term="工程" scheme="http://blog.zevzhang.top/categories/%E5%B7%A5%E7%A8%8B/"/>
    
    
    <category term="Spring" scheme="http://blog.zevzhang.top/tags/Spring/"/>
    
    <category term="一些很鸡贼的方法" scheme="http://blog.zevzhang.top/tags/%E4%B8%80%E4%BA%9B%E5%BE%88%E9%B8%A1%E8%B4%BC%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>好吧，我转到gitment了</title>
    <link href="http://blog.zevzhang.top/2017/09/24/%E5%A5%BD%E5%90%A7%EF%BC%8C%E6%88%91%E8%BD%AC%E5%88%B0gitment%E4%BA%86/"/>
    <id>http://blog.zevzhang.top/2017/09/24/%E5%A5%BD%E5%90%A7%EF%BC%8C%E6%88%91%E8%BD%AC%E5%88%B0gitment%E4%BA%86/</id>
    <published>2017-09-24T08:34:33.000Z</published>
    <updated>2024-12-22T07:02:21.597Z</updated>
    
    <content type="html"><![CDATA[<img src="http://pic.zevzhang.top/blog/github.jpeg" width = "400" alt="github大法好！"/><hr><p>上周在yilia上折腾了友言之后，经过了一周的试用，在经历了无法在本地调试，上传上去后莫名其妙不显示，阶段性抽风大姨妈后，我最终还是败给友言了。。。我还是老老实实用Gitment吧~~</p><p>github大法好！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;http://pic.zevzhang.top/blog/github.jpeg&quot; width = &quot;400&quot; alt=&quot;github大法好！&quot;/&gt;

&lt;hr&gt;
&lt;p&gt;上周在yilia上折腾了友言之后，经过了一周的试用，在经历了无法在本地调试，上传上去后莫名其</summary>
      
    
    
    
    <category term="随笔" scheme="http://blog.zevzhang.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="hexo" scheme="http://blog.zevzhang.top/tags/hexo/"/>
    
    <category term="yilia" scheme="http://blog.zevzhang.top/tags/yilia/"/>
    
    <category term="gitment" scheme="http://blog.zevzhang.top/tags/gitment/"/>
    
  </entry>
  
  <entry>
    <title>yilia主题增加友言支持</title>
    <link href="http://blog.zevzhang.top/2017/09/16/yilia%E4%B8%BB%E9%A2%98%E5%A2%9E%E5%8A%A0%E5%8F%8B%E8%A8%80%E6%94%AF%E6%8C%81/"/>
    <id>http://blog.zevzhang.top/2017/09/16/yilia%E4%B8%BB%E9%A2%98%E5%A2%9E%E5%8A%A0%E5%8F%8B%E8%A8%80%E6%94%AF%E6%8C%81/</id>
    <published>2017-09-16T08:25:39.000Z</published>
    <updated>2024-12-23T06:27:08.602Z</updated>
    
    <content type="html"><![CDATA[<p>自从网易云评论停止服务后，一直在寻找一个比较好用的评论服务。一直在用<a href="https://github.com/litten/hexo-theme-yilia">yilia</a>的模板，于是把yilia支持的几个评论服务都试了一下，多说跟网易云就不说了，已经停了服务；畅言需要ICP备案，对于普通博客来说申请ICP太麻烦了；Disqus虽然是老牌评论服务，但服务器在国外，不仅慢，登录也不方便；Gitment是给予GitHub Issues的评论系统，很好用，有动手能力的孩纸们可以尝试一下。</p><p>其实还有一款叫做友言的评论系统，后台很好用，管理起来很方便。虽然yilia目前模板并没有支持这款评论系统，但是我们可以通过对yilia模板进行简单修改，增加对友言的支持。</p><span id="more"></span><p>首先我们需要在<a href="http://www.uyan.cc/index.php">友言</a>的主页进行注册，注册后点击后台管理可以看到一个用户id。</p><p><img src="http://pic.zevzhang.top/blog/youyan/youyan.jpg"></p><p>article.ejs中添加检测配置文件中友言配置信息的检测代码,article.ejs文件在主题文件夹中的 layout&#x2F;_partial&#x2F;article.ejs</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.....</span><br><span class="line">&lt;% <span class="keyword">if</span> (!index &amp;&amp; post.<span class="property">comments</span>)&#123; %&gt;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 增加友言</span></span><br><span class="line">  &lt;% <span class="keyword">if</span> (theme.<span class="property">youyan_uid</span>)&#123; %&gt;</span><br><span class="line">  &lt;%- <span class="title function_">partial</span>(<span class="string">&#x27;post/youyan&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">youyan_uid</span>: theme.<span class="property">youyan_uid</span></span><br><span class="line">  &#125;) %&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下边的是原始代码</span></span><br><span class="line">  &lt;% <span class="keyword">if</span> (theme.<span class="property">duoshuo</span>)&#123; %&gt;</span><br><span class="line">  &lt;%- <span class="title function_">partial</span>(<span class="string">&#x27;post/duoshuo&#x27;</span>, &#123;</span><br><span class="line">      <span class="attr">key</span>: post.<span class="property">slug</span>,</span><br><span class="line">      <span class="attr">title</span>: post.<span class="property">title</span>,</span><br><span class="line">      <span class="attr">url</span>: config.<span class="property">url</span>+<span class="title function_">url_for</span>(post.<span class="property">path</span>)</span><br><span class="line">    &#125;) %&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br><span class="line">.....</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这段代码的作用是检测主题的配置文件中是否有youyan_uid，如果有的话，就调用post&#x2F;youyan这个插件并将uid传递给该插件。因此下一步我们需要编写youyan这个插件。首先在 layout&#x2F;_partial&#x2F;post文件夹下新建一个名为youyan.ejs的文件，文件内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- <span class="variable constant_">UY</span> <span class="variable constant_">BEGIN</span> --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;uyan_frame&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"> </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">var</span> uid = <span class="string">&quot;&lt;%=theme.youyan_uid%&gt;&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;&lt;script type=&quot;text/javascript&quot; src=&quot;http://v2.uyan.cc/code/uyan.js?uid=&#x27;</span> + uid + <span class="string">&#x27;&quot;&gt;&lt;\/script&gt;&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="comment">&lt;!-- UY END --&gt;</span></span></span><br></pre></td></tr></table></figure><p>最后我们需要在主题配置文件中添加一句：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 你的友言ID</span><br><span class="line">youyan_uid<span class="punctuation">:</span> <span class="number">1234567</span></span><br></pre></td></tr></table></figure><p>并且将其他评论系统配置项全部设置为false。</p><p>更新一下上传到你的服务器上，这样yilia就能显示友言的评论框了。</p><p><img src="http://pic.zevzhang.top/blog/youyan/youyan2.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;自从网易云评论停止服务后，一直在寻找一个比较好用的评论服务。一直在用&lt;a href=&quot;https://github.com/litten/hexo-theme-yilia&quot;&gt;yilia&lt;/a&gt;的模板，于是把yilia支持的几个评论服务都试了一下，多说跟网易云就不说了，已经停了服务；畅言需要ICP备案，对于普通博客来说申请ICP太麻烦了；Disqus虽然是老牌评论服务，但服务器在国外，不仅慢，登录也不方便；Gitment是给予GitHub Issues的评论系统，很好用，有动手能力的孩纸们可以尝试一下。&lt;/p&gt;
&lt;p&gt;其实还有一款叫做友言的评论系统，后台很好用，管理起来很方便。虽然yilia目前模板并没有支持这款评论系统，但是我们可以通过对yilia模板进行简单修改，增加对友言的支持。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="http://blog.zevzhang.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="hexo" scheme="http://blog.zevzhang.top/tags/hexo/"/>
    
    <category term="yilia" scheme="http://blog.zevzhang.top/tags/yilia/"/>
    
    <category term="友言" scheme="http://blog.zevzhang.top/tags/%E5%8F%8B%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Sigmoid函数总结</title>
    <link href="http://blog.zevzhang.top/2017/07/05/Sigmoid%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/"/>
    <id>http://blog.zevzhang.top/2017/07/05/Sigmoid%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/</id>
    <published>2017-07-05T01:44:11.000Z</published>
    <updated>2024-12-23T06:33:14.335Z</updated>
    
    <content type="html"><![CDATA[<p>Sigmoid函数又叫Logistic函数，它在机器学习领域有极其重要的地位。以前一直不是很理解Sigmoid函数的重要性，查了很多资料，大体上屡了一下，不过数学功底太差，很多地方理解的不够透彻。这里简单记录一下。</p><span id="more"></span><h1 id="一、函数基本性质"><a href="#一、函数基本性质" class="headerlink" title="一、函数基本性质"></a>一、函数基本性质</h1><p>首先Sigmoid的公式形式：<br>$$ S(t)&#x3D;\frac{1}{1+e^{-t}}$$</p><p>函数图像：</p><p><img src="http://pic.zevzhang.top/image/sigmoid/Logistic-curve.png" title="转自维基百科"></p><p>函数的基本性质：</p><ol><li>定义域：$(-\infty,+\infty)$</li><li>值域：$(0,1)$</li><li>函数在定义域内为连续和光滑函数</li><li>处处可导，导数为：$f^{‘}(x)&#x3D;f(x)(1-f(x))$</li></ol><p>最早Logistic函数是皮埃尔·弗朗索瓦·韦吕勒在1844或1845年在研究它与人口增长的关系时命名的。广义Logistic曲线可以模仿一些情况人口增长（P）的 S 形曲线。起初阶段大致是指数增长；然后随着开始变得饱和，增加变慢；最后，达到成熟时增加停止。[^LWiki]</p><h1 id="二、Sigmoid函数与逻辑回归"><a href="#二、Sigmoid函数与逻辑回归" class="headerlink" title="二、Sigmoid函数与逻辑回归"></a>二、Sigmoid函数与逻辑回归</h1><p>Sigmoid函数之所以叫Sigmoid，是因为函数的图像很想一个字母S。这个函数是一个很有意思的函数，从图像上我们可以观察到一些直观的特性：函数的取值在0-1之间，且在0.5处为中心对称，并且越靠近x&#x3D;0的取值斜率越大。</p><p>机器学习中一个重要的预测模型逻辑回归（LR）就是基于Sigmoid函数实现的。LR模型的主要任务是给定一些历史的{X,Y}，其中X是样本n个特征值，Y的取值是{0,1}代表正例与负例，通过对这些历史样本的学习，从而得到一个数学模型，给定一个新的X，能够预测出Y。LR模型是一个二分类模型，即对于一个X，预测其发生或不发生。但事实上，对于一个事件发生的情况，往往不能得到100%的预测，因此LR可以得到一个事件发生的可能性，超过50%则认为事件发生，低于50%则认为事件不发生</p><p>从LR的目的上来看，在选择函数时，有两个条件是必须要满足的：</p><ol><li>取值范围在0~1之间。</li><li>对于一个事件发生情况，50%是其结果的分水岭，选择函数应该在0.5中心对称。</li></ol><p>从这两个条件来看，Sigmoid很好的符合了LR的需求。关于逻辑回归的具体实现与相关问题，可看这篇文章<a href="http://wenjunoy.com/2016/01/logistic-sigmoid-function.html">Logistic函数（sigmoid函数） - wenjun’s blog</a>，在此不再赘述。</p><h1 id="三、为什么要选择Sigmoid函数？"><a href="#三、为什么要选择Sigmoid函数？" class="headerlink" title="三、为什么要选择Sigmoid函数？"></a>三、为什么要选择Sigmoid函数？</h1><p>很多文章讲到第二章就结束了，试着理解一下，第二章其实是在说LR模型可以选择Sigmoid函数实现，但是为什么选Sigmoid函数而不选择其他函数呢？这其实也是我一直困惑的点。例如仔细观察上述的两个条件，并不是只有Sigmoid能满足这两个条件，取值在0-1之间且以0.5值处中心对称的曲线函数有无数种。</p><p>可以从两个方面试着解释一下为什么选择Sigmoid函数。</p><h2 id="LR的需求（选择Sigmoid是可以的）"><a href="#LR的需求（选择Sigmoid是可以的）" class="headerlink" title="LR的需求（选择Sigmoid是可以的）"></a>LR的需求（选择Sigmoid是可以的）</h2><p>上边从直观上说明了LR可以选择Sigmoid，下面从从数学上解释一下LR模型的原理。</p><p>对于一个分类模型，我们需要给定一个学习目标，对于LR模型来说，这个目标是最大化条件似然度，对于给定一个已知的样本向量x，我们可以表示其对应的类标记y发生的概率为$P(y|x;w)$，在此基础上定义一个最大似然函数学习w，就可以得到一个有效的LR分类模型。</p><p>仔细观察上述对LR的描述，LR模型的重点是如何定义这个条件概率$P(y|x;w)$。对于一个有效的分类器，通常上response value(响应值)即$w\cdot x$（w和x的内积）代表了数据x属于正类（y&#x3D;1）的置信度。$w\cdot x$越大，这个数据属于正类的可能性越大；$w\cdot x$越小，属于反类的可能性越大。因此，如果我们有一个函数能够将$w\cdot x$映射到条件概率$P(y&#x3D;1|x;w)$，而sigmoid函数恰好能实现这一功能（参见sigmoid的函数形状）：首先，它的值域是（0,1），满足概率的要求；其次，它是一个单调上升函数。最终，$p(y&#x3D;1|x，w)&#x3D;sigmoid (w\cdot x)$。sigmoid的这些良好性质恰好能满足LR的需求。[^LRzhihu]</p><h2 id="Sigmoid特殊的性质（为什么选择Sigmoid）"><a href="#Sigmoid特殊的性质（为什么选择Sigmoid）" class="headerlink" title="Sigmoid特殊的性质（为什么选择Sigmoid）"></a>Sigmoid特殊的性质（为什么选择Sigmoid）</h2><p>这里给出两个解释：（个人感觉第二个更准确一点，不过真心看不懂🙄）</p><h3 id="正态分布解释"><a href="#正态分布解释" class="headerlink" title="正态分布解释"></a>正态分布解释</h3><p>大多数情况下，并没有办法知道未知事件的概率分布形式，而在无法得知的情况下，正态分布是一个最好的选择，因为它是所有概率分布中最可能的表现形式。正态分布的概率密度函数如下：</p><p>$f(x)&#x3D;\frac{1}{\delta \sqrt{2 \pi}}e^{-\frac{(x-u)^2}{2\delta^{2}}}$</p><p>在笛卡尔坐标系下，正态分布的函数呈现出“钟”形，如下图。图中四条曲线代表参数不同的四个正态分布。</p><p><img src="http://pic.zevzhang.top/blog/Normal_Distribution_PDF.png" alt="维基百科"></p><p>在假定某个事件的概率分布符合正态分布的规律后，要分析其可能发生的概率，就要看它的积分形式，上图四个正态分布的曲线如图：</p><p><img src="http://pic.zevzhang.top/blog/Normal_Distribution_CDF.png" alt="维基百科"></p><p>Sigmoid函数和正态分布函数的积分形式形状非常类似。但计算正态分布的积分函数，计算代价非常大，而Sigmoid的形式跟它相似，却由于其公式简单，计算量非常的小，因此被选为替代函数。[^ztfb]</p><h3 id="最大熵解释"><a href="#最大熵解释" class="headerlink" title="最大熵解释"></a>最大熵解释</h3><p>该解释是说，在我们给定了某些假设之后，我们希望在给定假设前提下，分布尽可能的均匀。对于Logistic Regression，我们假设了对于{X,Y}，我们预测的目标是$Y|X$，并假设认为$Y|X$服从bernoulli distribution，所以我们只需要知道$P(Y|X)$；其次我们需要一个线性模型，所以$P(Y|X) &#x3D; f(wx)$。接下来我们就只需要知道f是什么就行了。而我们可以通过最大熵原则推出的这个f，就是sigmoid。[^zhihuniming]</p><p>这里给出推导过程，大神们可以看看，我是真没看懂：<br><a href="http://www.win-vector.com/dfiles/LogisticRegressionMaxEnt.pdf">LogisticRegressionMaxEnt.pdf</a></p><h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p>综上所述，Logistics Regression之所以选择Sigmoid或者说Logistics函数，因为它叫Logistics Regression🙄。</p><p><img src="http://pic.zevzhang.top/image/sigmoid/zhengjing.jpg"></p><p>没错，我是正经的，之所以这样说是因为问题在于，并不是只有Sigmoid函数能解决二分类问题。</p><blockquote><p>为什么要选用sigmoid函数呢？为什么不选用其他函数，如probit函数？<br>其实，无论是sigmoid函数还是probit函数都是广义线性模型的连接函数（link function）中的一种。选用联接函数是因为，从统计学角度而言，普通线性回归模型是基于响应变量和误差项均服从正态分布的假设，且误差项具有零均值，同方差的特性。但是，例如分类任务（判断肿瘤是否为良性、判断邮件是否为垃圾邮件），其响应变量一般不服从于正态分布，其服从于二项分布，所以选用普通线性回归模型来拟合是不准确的，因为不符合假设，所以，我们需要选用广义线性模型来拟合数据，通过标准联接函数(canonical link or standard link function)来映射响应变量，如：正态分布对应于恒等式，泊松分布对应于自然对数函数，二项分布对应于logit函数（二项分布是特殊的泊松分布）。因此，说了这么多是想表达联接函数的选取除了必须适应于具体的研究案例，不用纠结于为什么现有的logistic回归会选用sigmoid函数，而不选用probit函数，虽然网上也有不少说法说明为什么选择sigmoid函数，例如“该函数有个漂亮的S型”，“在远离x＝0的地方函数的值会很快接近0&#x2F;1”，“函数在定义域内可微可导”，这些说法未免有些“马后炮”的感觉，哪个说法仔细分析都不能站住脚，我觉得选用sigmoid函数也就是因为该函数满足分类任务，用的人多了也就成了默认说法，这跟给物体取名字有点类似的感觉，都有些主观因素在其中。[^LRSig]</p></blockquote><p>[^LWiki]: <a href="https://zh.wikipedia.org/wiki/%E9%82%8F%E8%BC%AF%E5%87%BD%E6%95%B8">逻辑函数 - 维基百科</a></p><p>[^LRzhihu]: <a href="https://www.zhihu.com/question/35322351/answer/65308207">知乎-为什么 LR 模型要使用 sigmoid 函数，背后的数学原理是什么？-谢澎涛的回答</a></p><p>[^LRSig]: <a href="http://www.hanlongfei.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/2015/08/05/mle/">机器学习－逻辑回归与最大似然估计 - Longfei Han</a></p><p>[^ztfb]: <a href="https://blog.liushuping.com/2016/06/24/Sigmoid%E4%BB%80%E4%B9%88%E9%AC%BC/">Sigmoid什么鬼_ _ Shuping LIU</a></p><p>[^zhihuniming]: <a href="https://www.zhihu.com/question/35322351/answer/67193153">知乎-为什么 LR 模型要使用 sigmoid 函数，背后的数学原理是什么？-匿名回答</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Sigmoid函数又叫Logistic函数，它在机器学习领域有极其重要的地位。以前一直不是很理解Sigmoid函数的重要性，查了很多资料，大体上屡了一下，不过数学功底太差，很多地方理解的不够透彻。这里简单记录一下。&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="http://blog.zevzhang.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="sigmoid" scheme="http://blog.zevzhang.top/tags/sigmoid/"/>
    
    <category term="机器学习" scheme="http://blog.zevzhang.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>网络表示学习总结</title>
    <link href="http://blog.zevzhang.top/2017/06/23/%E7%BD%91%E7%BB%9C%E8%A1%A8%E7%A4%BA%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>http://blog.zevzhang.top/2017/06/23/%E7%BD%91%E7%BB%9C%E8%A1%A8%E7%A4%BA%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</id>
    <published>2017-06-23T13:08:41.000Z</published>
    <updated>2024-12-22T07:02:21.595Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近看了paperweekly的两次关于网络表示学习的直播，涂存超博士与杨成博士讲解了网络表示学习的相关知识。本文将网络表示学习中的一些基本知识，结合自己的一些粗浅的理解，整理记录下来。</p></blockquote><span id="more"></span><h2 id="网络的邻接矩阵表示"><a href="#网络的邻接矩阵表示" class="headerlink" title="网络的邻接矩阵表示"></a>网络的邻接矩阵表示</h2><p>用邻接矩阵是最直观的对网络数据的表示方法。在一个N个节点网络中，一个节点可以用N维向量来表示。</p><p>对一个N个节点的网络，用N*N的矩阵来表示一个网络，两个节点之间有边，则在对应的位置标记1（或者边的权值）。</p><p>下图所示为一个简单无向图的邻接矩阵表示，其中矩阵是沿对角对称的。</p><p><img src="http://pic.zevzhang.top/iamge/network_embedding/nod_adjacent_matrix.jpg" alt="有向图邻接矩阵"></p><p>若图为一个无向图，邻接矩阵不一定沿对角对称。</p><p><img src="http://pic.zevzhang.top/iamge/network_embedding/adjacent_matrix.jpg" alt="无向图邻接矩阵"></p><p>邻接矩阵表示一个图，可以将矩阵的每一行，看做一个节点对应的向量，这种表示方法与文本表示中词的One-Hot表示方法。这种表示方法能够完整地表示图数据，准确地表示网络中的链接关系，但是弊端也很明显，对于一个N个节点的网络，表达这个网络需要N*N的矩阵，并且矩阵过于稀疏，不利于存储大规模网络。</p><h2 id="网络的分布式表示"><a href="#网络的分布式表示" class="headerlink" title="网络的分布式表示"></a>网络的分布式表示</h2><p>分布式表示（Distributed Representation)最早是由Hinton在1986年提出的一种词向量的表示方法，其核心思想是将词向量映射到一个K维的向量空间中，这样每个词可以用K维向量来表示。大名鼎鼎的Word2vec就是一种对词的分布式表示方案。</p><p>同理，将这个概念应用于网络数据中，即网络的分布式表示，网络中的每个节点对应文本中的每个单词，其表示过程就是将每个节点映射到一个K维的向量空间（通常情况下，K远小于网络中节点个数），用K维向量来表示每个节点。事实上，我们可以将这个过程理解为对网络结点的向量表示进行降维的过程，对于一个N个节点的网络，邻接矩阵表示法用N维向量来表示一个节点。但通过这样的降维过程，仅使用K维向量就可以表示一个节点，并且节点向量还能包含一定的“语义”信息，例如连接紧密的结点向量的距离也很相近。这样就将一个高纬向量表示为低维稠密的实值向量。</p><p>通常情况下，我们通过对每个节点的向量进行一定的限定，从而给定一个优化方向进行优化，得到一个最优化的结果，即为节点的表示向量。优化目标的设计，往往希望能够尽可能多的将网络信息通过向量表示出来，并使得到的向量具有一定的计算能力。在这个目标的前提下，在优化的过程中，往往会将网络的结构、节点的信息、边的信息等“嵌入”到节点向量中，因此，我们也常常将网络的表示学习过程叫做网络嵌入（Network Embedding)。通过设计特定的优化目标，我们可以将节点的不同信息嵌入到向量中，将节点映射到不同的低维向量空间。</p><p>下图所示的是Deepwalk[^deepwalk]论文中所展示的节点向量，左图为原始网络，右图为将其映射到二维向量空间后的散点图，我们可以从图中看到，原始图中联系紧密的结点在映射到二维向量空间后距离较近，相同颜色的结点在原始图中联系紧密，在二维向量空间中分布较为密集。</p><p><img src="http://pic.zevzhang.top/image/deepwalk/deepwalk1.png" alt="来自于DeepWalk"></p><h2 id="网络表示学习的经典工作"><a href="#网络表示学习的经典工作" class="headerlink" title="网络表示学习的经典工作"></a>网络表示学习的经典工作</h2><h3 id="Deepwalk"><a href="#Deepwalk" class="headerlink" title="Deepwalk"></a>Deepwalk</h3><p>Deepwalk[^deepwalk]是2014年发表在KDD上的一篇论文，这篇文章受到了word2vec[^word2vec]的启发，文章的思路就是对网络应用了word2vec的SkipGram模型。SkipGram模型原本是针对文本的，或者说是针对有序序列的，所以文章先应用随机游走得到一系列的网络中有序的节点序列，这些节点序列类似于文本中的句子，将这些“句子”跑SkipGram模型，从而得到“句子”每个“单词”的向量表示。过程如下图所示：</p><p><img src="http://pic.zevzhang.top/iamge/network_embedding/deepwalk.jpg" alt="deepwalk过程"></p><p>Deepwalk的随机游走过程事实上是对网络进行采样的过程，将网络中的节点通过随机游走的方式表示出来，两个节点联系越紧密，在一个随机游走过程中共现的可能性越大，反之若两个节点根本不连通，则一个随机游走过程是不可能将两个节点共现。因此deepwalk能很好的将网络的连接情况进行表达，且实验证明在网络规模较大时具有很高的效率。</p><h3 id="LINE"><a href="#LINE" class="headerlink" title="LINE"></a>LINE</h3><p>LINE[^line]是2015年提出的一中网络表示学习方法，该方法提出了一阶相似度与二阶邻近度的概念，基于这两个邻近度，提出了优化函数，得到的最优化结果即为每个节点的向量表示。</p><p>该方法的优化过程可以理解为基于两个假设：</p><ol><li>直接相连的节点表示尽可能相近（一阶邻近度），如图中6,7。文中两个节点的联合概率表示其一阶邻近度：<center><font size="5px">$p_1(v_i,v_j)=\frac{1}{1+exp(-{\vec{u}}_i^T \cdot \vec{u}_j)}$</font></center></li><li>两个节点公共的邻居节点越多，两个节点的表示越相近（二阶邻近度），如图中5,6。文中用两个节点的条件概率表示其二阶邻近度：<center>![](http://pic.zevzhang.top/image/blog/20170623_line/equ2.png)</center></li></ol><p><img src="http://pic.zevzhang.top/iamge/network_embedding/LINE.png" alt="来自于LINE论文"></p><h3 id="node2vec"><a href="#node2vec" class="headerlink" title="node2vec"></a>node2vec</h3><p>node2vec[^node2vec]是2016年提出的一种方法，该方法在deepwalk的基础上进行了优化。deepwalk中的随机游走过程，实际是就是一种简单的深搜过程，每次随机随出一个与当前节点直接相连的节点作为后继节点，这种方法虽然能够保证采样到网络中的全局信息，但是对于该节点为中心的局部信息往往不能很好的进行采样。node2vec改进了这个随机游走的过程，它将广度优先搜索与深度优先搜索相结合。</p><p><img src="http://pic.zevzhang.top/iamge/network_embedding/node2vec.png" alt="来自于node2vec论文"></p><p>node2vec的随机游走是一个参数控制的随机游走，不同于deepwalk的随机游走，当前节点到后继节点的概率并不是完全相等的。例如下图所示的情况，v为随机游走的当前节点，它的前驱节点为t，那么下一步需要判断v相连的下一个节点，以便进行进一步的游走，这时与其相连的节点的类型有三种：一种是t，v的前驱节点；第二种是$x_1$，不仅与v相连，还与其前驱节点相连；第三种是$x_2$、$x_3$，不是v的前驱同时也不与其前驱相连。</p><p><img src="http://pic.zevzhang.top/iamge/network_embedding/node2vec2.png" alt="来自于node2vec论文"></p><p>如果节点向第一种节点游走，则返回前驱节点；向第二种节点游走，则为广搜的过程；向第三种节点游走则为深搜的过程。为了控制广搜与深搜，因此设计了参数$p$和$q$，通过这两个参数计算出偏移$a$，则真正的游走概率为原始概率的基础上乘上$a$得到。通过调整这两个参数，可以控制广搜和深搜的程度。所以deepwalk中的随机游走过程，就是一个$p&#x3D;1$、$q&#x3D;1$的node2vec。</p><h2 id="网络表示学习的相关论文"><a href="#网络表示学习的相关论文" class="headerlink" title="网络表示学习的相关论文"></a>网络表示学习的相关论文</h2><p>涂存超博士在github上整理了一些相关论文，我就直接拿来主义了，链到涂存超博士的github上。</p><p><a href="https://github.com/thunlp/NRLPapers">Must-read papers on network representation learning (NRL)&#x2F;network embedding (NE)</a></p><p>[^deepwalk]: Perozzi B, Al-Rfou R, Skiena S. Deepwalk: Online learning of social representations[C]&#x2F;&#x2F;Proceedings of the 20th ACM SIGKDD international conference on Knowledge discovery and data mining. ACM, 2014: 701-710.<br>[^word2vec]: Mikolov T, Sutskever I, Chen K, et al. Distributed representations of words and phrases and their compositionality[C]&#x2F;&#x2F;Advances in neural information processing systems. 2013: 3111-3119.<br>[^line]: Tang J, Qu M, Wang M, et al. Line: Large-scale information network embedding[C]&#x2F;&#x2F;Proceedings of the 24th International Conference on World Wide Web. International World Wide Web Conferences Steering Committee, 2015: 1067-1077.<br>[^node2vec]: Grover A, Leskovec J. node2vec: Scalable feature learning for networks[C]&#x2F;&#x2F;Proceedings of the 22nd ACM SIGKDD international conference on Knowledge discovery and data mining. ACM, 2016: 855-864.</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;最近看了paperweekly的两次关于网络表示学习的直播，涂存超博士与杨成博士讲解了网络表示学习的相关知识。本文将网络表示学习中的一些基本知识，结合自己的一些粗浅的理解，整理记录下来。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="papers" scheme="http://blog.zevzhang.top/categories/papers/"/>
    
    
    <category term="表示学习" scheme="http://blog.zevzhang.top/tags/%E8%A1%A8%E7%A4%BA%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Network" scheme="http://blog.zevzhang.top/tags/Network/"/>
    
    <category term="Network Embedding" scheme="http://blog.zevzhang.top/tags/Network-Embedding/"/>
    
  </entry>
  
  <entry>
    <title>【论文笔记】DeepWalk: Online Learning of Social Representations</title>
    <link href="http://blog.zevzhang.top/2017/06/08/%E3%80%8ADeepWalk-Online-Learning-of-Social-Representations%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://blog.zevzhang.top/2017/06/08/%E3%80%8ADeepWalk-Online-Learning-of-Social-Representations%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2017-06-08T03:06:12.000Z</published>
    <updated>2024-12-23T06:24:28.370Z</updated>
    
    <content type="html"><![CDATA[<p>先附上文章链接 <a href="https://arxiv.org/abs/1403.6652">DeepWalk: Online Learning of Social Representations</a></p><p>作者也将python版的deepwalk开源了 <a href="https://github.com/phanein/deepwalk">GitHub地址</a></p><p>大神的关于这篇文章的主页，里面有PPT <a href="http://www.perozzi.net/projects/deepwalk/">链接</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在看一些图嵌入、图迁移学习相关的paper，陆续会将读到的一些有意思的paper整理成学习笔记。篇章中的一些个人看法与理解可能会有不恰当的地方，欢迎大家一起讨论。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Deepwalk这篇paper是有一篇很有意思的文章，整篇paper都在探讨一件事：将一个网络中的每个节点映射成一个低维的向量。说白了就是用一个向量去表示网络中的每个节点，并且希望这些向量能够将网络中的节点中的关系表达出来，即希望在原始网络中关系越紧密的结点对应的向量在其空间中距离越近。用张图表示如下所示（出自论文）：</p><p><img src="http://pic.zevzhang.top/image/deepwalk/deepwalk1.png"></p><span id="more"></span><p>输入的是一个网络，其中颜色相同的结点表示拓扑关系上更为相近的结点。输出的是每个节点的二维向量，每个节点对应的向量关系如图所示。我们可以从这个图看出，越是拓扑结构相近的点，其对应的二维向量在二维空间上距离与近。</p><p>我个人理解可以将这个过程理解为一个降维的过程，但是不同于传统意义上的高纬度降到低纬度，而是将一个复杂的结构降到低纬度。或者说可以理解为，将网络中的拓扑结构，嵌入到一个低维向量中，每个节点的低维向量，从某种程度上反应了该节点在网络中的连接情况。</p><h1 id="这样做的好处"><a href="#这样做的好处" class="headerlink" title="这样做的好处"></a>这样做的好处</h1><p>这样做有什么目的呢？</p><p>我认为最主要的好处，就是便于将一些机器学习的算法应用到网络中。网络数据不同于传统的数据，它不仅包含了节点的信息，还包含了节点间的关系，对于传统的机器学习算法，很难将其应用于网络中。例如网络中的社团发现算法，大多数情况下我们都针对网络做大量的游走，不断改变网络的社团结构，以使网络获得最优的模块度，但是如果我们能将拓扑信息嵌入到低维向量中，那么每个节点我们都可以看做是一个样本，每个维度都可以看做一个feature，那么只需要跑个聚类算法，就可以得到很好的结果。除了聚类，还有链路预测、推荐等一系列网络中的问题，都可以直接扔到机器学习的相关算法中跑出来。</p><h1 id="如何得到对应的向量"><a href="#如何得到对应的向量" class="headerlink" title="如何得到对应的向量"></a>如何得到对应的向量</h1><p>我觉得作者的思路很讨巧。我们都知道word2vec能够将文本中的每个词映射到一个低维向量中，这个目标很像Deepwalk的目标。但是word2vec针对的是文本，或者说是有序的单词序列，Deepwalk针对的是带有拓扑结构的网络。</p><p>于是作者提出了一个思路，针对每个节点跑了个随机游走，游走过程中就得到了一系列的有序节点序列，这些节点序列可以类比于文章的句子，节点类比于句子中的单词，然后再使用word2vec跑，得到对应的向量。</p><p>上边的思路可行不可行，重点是要证明网络中的节点与文本中的词相似不相似，于是作者针对YouTube的社交网络与Wikipedia的文章进行了研究，比较了在短的随机游走中节点出现的频度与文章中单词的频度进行了比较，可以得出二者基本上类似。（说实话我不是很理解这样的比较有什么意义，可能我对word2vec理解的不够。确实两个图比较相似，这个就是证明了一下<a href="https://zh.wikipedia.org/wiki/%E9%BD%8A%E5%A4%AB%E5%AE%9A%E5%BE%8B">Zipf’s law</a>，关键能不能用word2vec取决于这个吗？）</p><p><img src="http://pic.zevzhang.top/image/deepwalk/deepwalk2.png"></p><p>证明了二者相似，就可以用类似语言模型的方法研究图数据。本文中实际上就是用了word2vec的方法训练出了“词向量”。</p><h1 id="相关算法"><a href="#相关算法" class="headerlink" title="相关算法"></a>相关算法</h1><p>实现的过程不是很复杂，事实上就两步,一步游走，一步SkipGram，游走的过程事实上是一个深搜的游走，SkipGram跟word2vec的相似，我就不细说了，直接贴了论文中的图：</p><p><img src="http://pic.zevzhang.top/image/deepwalk/deepwalk3.png"><br><img src="http://pic.zevzhang.top/image/deepwalk/deepwalk4.png"></p><p>同时作者也在GitHub上开源了Python版本的<a href="https://github.com/phanein/deepwalk">Deepwalk</a>，大家可以与研究研究，它的随机游走过程很有意思，直接随了若干个点，同时SkipGram过程，直接用的Gensim的word2vec。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>关于图嵌入，图降维的研究，好像很早就有人做过，但都没有像这篇文章如此有影响力。感觉这篇文章的意义在于，它为图研究找到了一个很好的表示学习方法，开辟了一个图研究的新领域，这导致这两年Graph Embedding火的不行，随便一个大数据、社交网络的会，都得有几篇是做embedding的。</p><p>我个人很推崇这篇文章的，虽然仔细品品好像是将两个模型糅杂在一起，但就是很佩服作者的想法。不过客观来讲，文中有部分地方还是有很大的改进空间的，比如随机游走过程，本文提出的更像是随机地进行深搜，后来的很多文章，例如<a href="https://arxiv.org/pdf/1503.03578.pdf">LINE</a>、<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5108654/">Node2vec</a>都有在这方面有进行改进。还有一点就是LINE里面提到的，Deepwalk中没有提出一个明确的目标函数（这是不是机器学习专家的职业病，非得把问题转化为最优化问题…），虽然我也不知道这个算不算一个缺点，但是感觉说的确实有点道理(￣▽￣)~*</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;先附上文章链接 &lt;a href=&quot;https://arxiv.org/abs/1403.6652&quot;&gt;DeepWalk: Online Learning of Social Representations&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者也将python版的deepwalk开源了 &lt;a href=&quot;https://github.com/phanein/deepwalk&quot;&gt;GitHub地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;大神的关于这篇文章的主页，里面有PPT &lt;a href=&quot;http://www.perozzi.net/projects/deepwalk/&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近在看一些图嵌入、图迁移学习相关的paper，陆续会将读到的一些有意思的paper整理成学习笔记。篇章中的一些个人看法与理解可能会有不恰当的地方，欢迎大家一起讨论。&lt;/p&gt;
&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;Deepwalk这篇paper是有一篇很有意思的文章，整篇paper都在探讨一件事：将一个网络中的每个节点映射成一个低维的向量。说白了就是用一个向量去表示网络中的每个节点，并且希望这些向量能够将网络中的节点中的关系表达出来，即希望在原始网络中关系越紧密的结点对应的向量在其空间中距离越近。用张图表示如下所示（出自论文）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pic.zevzhang.top/image/deepwalk/deepwalk1.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="论文笔记" scheme="http://blog.zevzhang.top/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="表示学习" scheme="http://blog.zevzhang.top/tags/%E8%A1%A8%E7%A4%BA%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Graph Embedding" scheme="http://blog.zevzhang.top/tags/Graph-Embedding/"/>
    
    <category term="论文笔记" scheme="http://blog.zevzhang.top/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>WIFI模块ESP8266测试</title>
    <link href="http://blog.zevzhang.top/2017/04/01/WIFI%E6%A8%A1%E5%9D%97ESP8266%E6%B5%8B%E8%AF%95/"/>
    <id>http://blog.zevzhang.top/2017/04/01/WIFI%E6%A8%A1%E5%9D%97ESP8266%E6%B5%8B%E8%AF%95/</id>
    <published>2017-04-01T15:18:11.000Z</published>
    <updated>2024-12-23T06:27:00.839Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学习Arduino，一直想搞点大事情，弄来弄去，感觉不能联网的Arduino总是缺了点什么，于是买了块ESP8266，这里记录一下ESP8266接串口usb模块的调试测试过程。由于我也刚接触嵌入式不久，第一次碰这个模块，一边学习一边记录，写的东西可能有漏洞，欢迎各位大神批评指正。</p><span id="more"></span><h1 id="ESP8266模块简介"><a href="#ESP8266模块简介" class="headerlink" title="ESP8266模块简介"></a>ESP8266模块简介</h1><p>ESP8266有几款不同的型号，用的比较多的差不多ESP8266-01，-07，-12E，和-13，我买的是一款借口比较简单一点的ESP-01，资料也挺丰富的，酱婶的。</p><p><img src="http://pic.zevzhang.top/esp8266/esp7.jpg"></p><p>刚拿到的时候，本来以为只是像蓝牙模块一样的单独的wifi模块，仔细观察了一下，发现竟然还有两个GPIO接口。查查资料发现，ESP8266更确切的说是一块带WIFI的单片机，cpu是基于xtensa的架构。不同的型号提供的GPIO接口的个数不一样，较少的向这块，有2个接口，多的比如ESP-12E，GPIO就有9个之多，完全可以应付一些简单的应用场景。在这里，我们不去研究如何使用它的GPIO，我们只将其作为一个wifi模块，探究如何通过它让单片机拥有无线功能。</p><h1 id="ESP8266模块与单片机通信原理"><a href="#ESP8266模块与单片机通信原理" class="headerlink" title="ESP8266模块与单片机通信原理"></a>ESP8266模块与单片机通信原理</h1><p>ESP8266支持串口通讯，所以该模块与单片机数据交互主要靠串口进行。但与常见的用串口通信的模块不太一样，ESP8266与单片机通讯，更像两台写好协议的机器之间通信，单片机要向ESP8266发指令，然后根据发出的指令，返回对应的数据。</p><p>模块主要使用AT指令集，通过该指令集可以完成对模块模式的设置、数据的发送、数据的收取等功能，基本上可以实现简单的wifi数据交互。</p><p>关于ESP8266的AT指令，我找到了份详细的说明：<br><a href="https://github.com/espressif/esp8266_at/wiki">https://github.com/espressif/esp8266_at/wiki</a></p><h1 id="ESP8266模块功能测试"><a href="#ESP8266模块功能测试" class="headerlink" title="ESP8266模块功能测试"></a>ESP8266模块功能测试</h1><p>主要是为了探究ESP8266的功能，所以不牵扯单片机了，以免调试不直观，我直接将其通过usb串口模块与电脑连起来，进行串口数据测试。</p><h2 id="1、模块连接"><a href="#1、模块连接" class="headerlink" title="1、模块连接"></a>1、模块连接</h2><p>USB串口模块如下图所示：</p><p><img src="http://pic.zevzhang.top/esp8266/8.jpg"></p><p>连接很简单，说白了就是使用usb输出的VCC和GND给ESP供电，CH-PD端口给个高电平，然后串口互连就可以了。在此不在赘述，照着下图连就可以（UBS串口我没找到合适的元件图片）。其中一定注意，ESP的供电是3.3v，千万不要接成5v，很容易烧坏芯片。如果实验的usb模块没有3.3v输出，可以把Arduino和USB模块同时插到电脑上，使其电平一致，然后用Arduino的3.3v给ESP供电。</p><p><img src="http://pic.zevzhang.top/esp8266/espyuanli.jpg"></p><h2 id="2、测试软件"><a href="#2、测试软件" class="headerlink" title="2、测试软件"></a>2、测试软件</h2><p>就两个，一个串口通信的工具，一个网络通信的工具，我都收集好了，大家测试的时候可以直接下载。</p><p><a href="http://pic.zevzhang.top/file/blog/ESP-sscom42.zip">sscom</a></p><p><a href="http://pic.zevzhang.top/file/blog/ESP-USR-TCP232-Test-V1.3.exe">USR-TCP232</a></p><h2 id="3、串口测试"><a href="#3、串口测试" class="headerlink" title="3、串口测试"></a>3、串口测试</h2><p>按照图连接好后，把usb模块插到电脑上并安装好驱动，win7应该是默认安装的，win10自动装的驱动是不可以用的，得去下旧版本的。</p><p>打开sscom按照好后按照图修改一下参数,注意画红框的地方：</p><p><img src="http://pic.zevzhang.top/esp8266/1.png"></p><p>一般连接好后数据显示框就会有反应，有时候也没有，不懂为啥……在字符串输入框输入AT，敲回车，模块会返回“OK”，表示成功连接并正常通信。</p><h2 id="4、数据发送接收测试"><a href="#4、数据发送接收测试" class="headerlink" title="4、数据发送接收测试"></a>4、数据发送接收测试</h2><p>过程很直接，就是先设置模式，再连接wifi，再发送数据</p><p>具体可以见图，好吧其实是我懒得写了。。。</p><p><img src="http://pic.zevzhang.top/esp8266/2.png"></p><p>设置成双模式之后是能够在wifi列表找到该模块的wifi的：<br><img src="http://pic.zevzhang.top/esp8266/3.png"></p><p>连接好了就这样的：<br><img src="http://pic.zevzhang.top/esp8266/4.png"></p><p>USR-TCP要先设置一下，主要IP写本机的和模块统一网段下的IP，端口随意，但是连接的时候要对应起来。<br><img src="http://pic.zevzhang.top/esp8266/5.png"></p><p>数据交换也是通过AT指令进行的：<br><img src="http://pic.zevzhang.top/esp8266/6.png"></p><p>指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//设置成双模式</span><br><span class="line">AT+CWMODE=3</span><br><span class="line"></span><br><span class="line">//连接指定的wifi</span><br><span class="line">AT+CWJAP=&quot;ssid-name&quot;,&quot;wifi-password&quot;</span><br><span class="line"></span><br><span class="line">//显示当前连接的wifi信息</span><br><span class="line">AT+CIFSR</span><br><span class="line"></span><br><span class="line">//连接指定wifi接受数据</span><br><span class="line">AT+CIPSTART=&quot;TCP&quot;,&quot;serverIP&quot;,port</span><br><span class="line"></span><br><span class="line">//发送4个byte的数据</span><br><span class="line">AT+CIPSEND=4</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在学习Arduino，一直想搞点大事情，弄来弄去，感觉不能联网的Arduino总是缺了点什么，于是买了块ESP8266，这里记录一下ESP8266接串口usb模块的调试测试过程。由于我也刚接触嵌入式不久，第一次碰这个模块，一边学习一边记录，写的东西可能有漏洞，欢迎各位大神批评指正。&lt;/p&gt;</summary>
    
    
    
    <category term="开发板" scheme="http://blog.zevzhang.top/categories/%E5%BC%80%E5%8F%91%E6%9D%BF/"/>
    
    
    <category term="开发板" scheme="http://blog.zevzhang.top/tags/%E5%BC%80%E5%8F%91%E6%9D%BF/"/>
    
    <category term="ESP8266" scheme="http://blog.zevzhang.top/tags/ESP8266/"/>
    
  </entry>
  
  <entry>
    <title>Python调用百度语音REST API</title>
    <link href="http://blog.zevzhang.top/2017/03/16/Python%E8%B0%83%E7%94%A8%E7%99%BE%E5%BA%A6%E8%AF%AD%E9%9F%B3REST-API/"/>
    <id>http://blog.zevzhang.top/2017/03/16/Python%E8%B0%83%E7%94%A8%E7%99%BE%E5%BA%A6%E8%AF%AD%E9%9F%B3REST-API/</id>
    <published>2017-03-16T05:37:26.000Z</published>
    <updated>2024-12-23T06:27:07.193Z</updated>
    
    <content type="html"><![CDATA[<p>百度通过 REST API 的方式给开发者提供一个通用的 HTTP 接口，基于该接口，开发者可以轻松的获得语音合成与语音识别能力。SDK中只提供了PHP、C和JAVA的相关样例，使用python也可以灵活的对端口进行调用，本文描述了简单使用Python调用百度语音识别服务 REST API 的简单样例。</p><span id="more"></span><h2 id="1、语音识别与语音合成的调用"><a href="#1、语音识别与语音合成的调用" class="headerlink" title="1、语音识别与语音合成的调用"></a>1、语音识别与语音合成的调用</h2><p>注册开发者帐号和创建应用的过程就不再赘述，百度的REST API在调用过程基本分为三步：</p><ol><li>获取token</li><li>向Rest接口提交数据</li><li>处理返回数据</li></ol><p>具体代码如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaiduRest</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, cu_id, api_key, api_secert</span>):</span><br><span class="line">    <span class="comment"># token认证的url</span></span><br><span class="line">        <span class="variable language_">self</span>.token_url = <span class="string">&quot;https://openapi.baidu.com/oauth/2.0/token?grant_type=client_credentials&amp;client_id=%s&amp;client_secret=%s&quot;</span></span><br><span class="line">        <span class="comment"># 语音合成的resturl</span></span><br><span class="line">        <span class="variable language_">self</span>.getvoice_url = <span class="string">&quot;http://tsn.baidu.com/text2audio?tex=%s&amp;lan=zh&amp;cuid=%s&amp;ctp=1&amp;tok=%s&quot;</span></span><br><span class="line">        <span class="comment"># 语音识别的resturl</span></span><br><span class="line">        <span class="variable language_">self</span>.upvoice_url = <span class="string">&#x27;http://vop.baidu.com/server_api&#x27;</span></span><br><span class="line">        </span><br><span class="line">        <span class="variable language_">self</span>.cu_id = cu_id</span><br><span class="line">        <span class="variable language_">self</span>.getToken(api_key, api_secert)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getToken</span>(<span class="params">self, api_key, api_secert</span>):</span><br><span class="line">    <span class="comment"># 1.获取token</span></span><br><span class="line">        token_url = <span class="variable language_">self</span>.token_url % (api_key,api_secert)</span><br><span class="line"></span><br><span class="line">        r_str = urllib.request.urlopen(token_url).read()</span><br><span class="line">        token_data = json.loads(r_str)</span><br><span class="line">        <span class="variable language_">self</span>.token_str = token_data[<span class="string">&#x27;access_token&#x27;</span>]</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getVoice</span>(<span class="params">self, text, filename</span>):</span><br><span class="line">    <span class="comment"># 2. 向Rest接口提交数据</span></span><br><span class="line">        get_url = <span class="variable language_">self</span>.getvoice_url % (urllib.parse.quote(text), <span class="variable language_">self</span>.cu_id, <span class="variable language_">self</span>.token_str)</span><br><span class="line"></span><br><span class="line">        voice_data = urllib.request.urlopen(get_url).read()</span><br><span class="line">        <span class="comment"># 3.处理返回数据</span></span><br><span class="line">        voice_fp = <span class="built_in">open</span>(filename,<span class="string">&#x27;wb+&#x27;</span>)</span><br><span class="line">        voice_fp.write(voice_data)</span><br><span class="line">        voice_fp.close()</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getText</span>(<span class="params">self, filename</span>):</span><br><span class="line">    <span class="comment"># 2. 向Rest接口提交数据</span></span><br><span class="line">        data = &#123;&#125;</span><br><span class="line">        <span class="comment"># 语音的一些参数</span></span><br><span class="line">        data[<span class="string">&#x27;format&#x27;</span>] = <span class="string">&#x27;wav&#x27;</span></span><br><span class="line">        data[<span class="string">&#x27;rate&#x27;</span>] = <span class="number">8000</span></span><br><span class="line">        data[<span class="string">&#x27;channel&#x27;</span>] = <span class="number">1</span></span><br><span class="line">        data[<span class="string">&#x27;cuid&#x27;</span>] = <span class="variable language_">self</span>.cu_id</span><br><span class="line">        data[<span class="string">&#x27;token&#x27;</span>] = <span class="variable language_">self</span>.token_str</span><br><span class="line">        wav_fp = <span class="built_in">open</span>(filename,<span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">        voice_data = wav_fp.read()</span><br><span class="line">        data[<span class="string">&#x27;len&#x27;</span>] = <span class="built_in">len</span>(voice_data)</span><br><span class="line">        data[<span class="string">&#x27;speech&#x27;</span>] = base64.b64encode(voice_data).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        post_data = json.dumps(data)</span><br><span class="line">        r_data = urllib.request.urlopen(<span class="variable language_">self</span>.upvoice_url,data=<span class="built_in">bytes</span>(post_data,encoding=<span class="string">&quot;utf-8&quot;</span>)).read()</span><br><span class="line">        <span class="comment"># 3.处理返回数据</span></span><br><span class="line">        <span class="keyword">return</span> json.loads(r_data)[<span class="string">&#x27;result&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"><span class="comment"># 我的api_key,供大家测试用，在实际工程中请换成自己申请的应用的key和secert</span></span><br><span class="line">    api_key = <span class="string">&quot;SrhYKqzl3SE1URnAEuZ0FKdT&quot;</span> </span><br><span class="line">    api_secert = <span class="string">&quot;hGqeCkaMPb0ELMqtRGc2VjWdmjo7T89d&quot;</span></span><br><span class="line">    <span class="comment"># 初始化</span></span><br><span class="line">    bdr = BaiduRest(<span class="string">&quot;test_python&quot;</span>, api_key, api_secert)</span><br><span class="line">    <span class="comment"># 将字符串语音合成并保存为out.mp3</span></span><br><span class="line">    bdr.getVoice(<span class="string">&quot;你好北京邮电大学!&quot;</span>, <span class="string">&quot;out.mp3&quot;</span>)</span><br><span class="line">    <span class="comment"># 识别test.wav语音内容并显示</span></span><br><span class="line">    <span class="built_in">print</span>(bdr.getText(<span class="string">&quot;out.wav&quot;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2、调用pyaudio使用麦克风录制声音"><a href="#2、调用pyaudio使用麦克风录制声音" class="headerlink" title="2、调用pyaudio使用麦克风录制声音"></a>2、调用pyaudio使用麦克风录制声音</h2><p>python中的pyaudio库可以直接通过麦克风录制声音，可使用pip进行安装。我们可以通过调用该库，获取到wav测试语音。<br>具体代码如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pyaudio <span class="keyword">import</span> PyAudio, paInt16 </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime </span><br><span class="line"><span class="keyword">import</span> wave</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">recoder</span>:</span><br><span class="line">    NUM_SAMPLES = <span class="number">2000</span>      <span class="comment">#pyaudio内置缓冲大小</span></span><br><span class="line">    SAMPLING_RATE = <span class="number">8000</span>    <span class="comment">#取样频率</span></span><br><span class="line">    LEVEL = <span class="number">500</span>         <span class="comment">#声音保存的阈值</span></span><br><span class="line">    COUNT_NUM = <span class="number">20</span>      <span class="comment">#NUM_SAMPLES个取样之内出现COUNT_NUM个大于LEVEL的取样则记录声音</span></span><br><span class="line">    SAVE_LENGTH = <span class="number">8</span>         <span class="comment">#声音记录的最小长度：SAVE_LENGTH * NUM_SAMPLES 个取样</span></span><br><span class="line">    TIME_COUNT = <span class="number">60</span>     <span class="comment">#录音时间，单位s</span></span><br><span class="line"></span><br><span class="line">    Voice_String = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">savewav</span>(<span class="params">self,filename</span>):</span><br><span class="line">        wf = wave.<span class="built_in">open</span>(filename, <span class="string">&#x27;wb&#x27;</span>) </span><br><span class="line">        wf.setnchannels(<span class="number">1</span>) </span><br><span class="line">        wf.setsampwidth(<span class="number">2</span>) </span><br><span class="line">        wf.setframerate(<span class="variable language_">self</span>.SAMPLING_RATE) </span><br><span class="line">        wf.writeframes(np.array(<span class="variable language_">self</span>.Voice_String).tostring()) </span><br><span class="line">        <span class="comment"># wf.writeframes(self.Voice_String.decode())</span></span><br><span class="line">        wf.close() </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recoder</span>(<span class="params">self</span>):</span><br><span class="line">        pa = PyAudio() </span><br><span class="line">        stream = pa.<span class="built_in">open</span>(<span class="built_in">format</span>=paInt16, channels=<span class="number">1</span>, rate=<span class="variable language_">self</span>.SAMPLING_RATE, <span class="built_in">input</span>=<span class="literal">True</span>, </span><br><span class="line">            frames_per_buffer=<span class="variable language_">self</span>.NUM_SAMPLES) </span><br><span class="line">        save_count = <span class="number">0</span> </span><br><span class="line">        save_buffer = [] </span><br><span class="line">        time_count = <span class="variable language_">self</span>.TIME_COUNT</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            time_count -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># print time_count</span></span><br><span class="line">            <span class="comment"># 读入NUM_SAMPLES个取样</span></span><br><span class="line">            string_audio_data = stream.read(<span class="variable language_">self</span>.NUM_SAMPLES) </span><br><span class="line">            <span class="comment"># 将读入的数据转换为数组</span></span><br><span class="line">            audio_data = np.fromstring(string_audio_data, dtype=np.short)</span><br><span class="line">            <span class="comment"># 计算大于LEVEL的取样的个数</span></span><br><span class="line">            large_sample_count = np.<span class="built_in">sum</span>( audio_data &gt; <span class="variable language_">self</span>.LEVEL )</span><br><span class="line">            <span class="built_in">print</span>(np.<span class="built_in">max</span>(audio_data))</span><br><span class="line">            <span class="comment"># 如果个数大于COUNT_NUM，则至少保存SAVE_LENGTH个块</span></span><br><span class="line">            <span class="keyword">if</span> large_sample_count &gt; <span class="variable language_">self</span>.COUNT_NUM:</span><br><span class="line">                save_count = <span class="variable language_">self</span>.SAVE_LENGTH </span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                save_count -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> save_count &lt; <span class="number">0</span>:</span><br><span class="line">                save_count = <span class="number">0</span> </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> save_count &gt; <span class="number">0</span> : </span><br><span class="line">            <span class="comment"># 将要保存的数据存放到save_buffer中</span></span><br><span class="line">                <span class="comment">#print  save_count &gt; 0 and time_count &gt;0</span></span><br><span class="line">                save_buffer.append( string_audio_data ) </span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">            <span class="comment">#print save_buffer</span></span><br><span class="line">            <span class="comment"># 将save_buffer中的数据写入WAV文件，WAV文件的文件名是保存的时刻</span></span><br><span class="line">                <span class="comment">#print &quot;debug&quot;</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(save_buffer) &gt; <span class="number">0</span> : </span><br><span class="line">                    <span class="variable language_">self</span>.Voice_String = save_buffer</span><br><span class="line">                    save_buffer = [] </span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;Recode a piece of  voice successfully!&quot;</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> time_count==<span class="number">0</span>: </span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(save_buffer)&gt;<span class="number">0</span>:</span><br><span class="line">                    <span class="variable language_">self</span>.Voice_String = save_buffer</span><br><span class="line">                    save_buffer = [] </span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;Recode a piece of  voice successfully!&quot;</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    r = recoder()</span><br><span class="line">    r.recoder()</span><br><span class="line">    r.savewav(<span class="string">&quot;test.wav&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;百度通过 REST API 的方式给开发者提供一个通用的 HTTP 接口，基于该接口，开发者可以轻松的获得语音合成与语音识别能力。SDK中只提供了PHP、C和JAVA的相关样例，使用python也可以灵活的对端口进行调用，本文描述了简单使用Python调用百度语音识别服务 REST API 的简单样例。&lt;/p&gt;</summary>
    
    
    
    <category term="开发板" scheme="http://blog.zevzhang.top/categories/%E5%BC%80%E5%8F%91%E6%9D%BF/"/>
    
    
    <category term="python" scheme="http://blog.zevzhang.top/tags/python/"/>
    
    <category term="开发板" scheme="http://blog.zevzhang.top/tags/%E5%BC%80%E5%8F%91%E6%9D%BF/"/>
    
  </entry>
  
</feed>
